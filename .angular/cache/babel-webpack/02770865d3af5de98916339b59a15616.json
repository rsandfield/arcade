{"ast":null,"code":"import { Tools } from \"../../Misc/tools\";\nimport { WorkerPool } from '../../Misc/workerPool';\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\n\nfunction createDecoderAsync(wasmBinary) {\n  return new Promise(function (resolve) {\n    DracoDecoderModule({\n      wasmBinary: wasmBinary\n    }).then(function (module) {\n      resolve({\n        module: module\n      });\n    });\n  });\n}\n\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData) {\n  var buffer = new decoderModule.DecoderBuffer();\n  buffer.Init(dataView, dataView.byteLength);\n  var decoder = new decoderModule.Decoder();\n  var geometry;\n  var status;\n\n  try {\n    var type = decoder.GetEncodedGeometryType(buffer);\n\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        geometry = new decoderModule.Mesh();\n        status = decoder.DecodeBufferToMesh(buffer, geometry);\n        break;\n\n      case decoderModule.POINT_CLOUD:\n        geometry = new decoderModule.PointCloud();\n        status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type \" + type);\n    }\n\n    if (!status.ok() || !geometry.ptr) {\n      throw new Error(status.error_msg());\n    }\n\n    if (type === decoderModule.TRIANGULAR_MESH) {\n      var numFaces = geometry.num_faces();\n      var numIndices = numFaces * 3;\n      var byteLength = numIndices * 4;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n        var indices = new Uint32Array(numIndices);\n        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n        onIndicesData(indices);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    }\n\n    var processAttribute = function (kind, attribute) {\n      var numComponents = attribute.num_components();\n      var numPoints = geometry.num_points();\n      var numValues = numPoints * numComponents;\n      var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n        var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n\n        if (kind === \"color\" && numComponents === 3) {\n          var babylonData = new Float32Array(numPoints * 4);\n\n          for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n            babylonData[i + 0] = values[j + 0];\n            babylonData[i + 1] = values[j + 1];\n            babylonData[i + 2] = values[j + 2];\n            babylonData[i + 3] = 1;\n          }\n\n          onAttributeData(kind, babylonData);\n        } else {\n          var babylonData = new Float32Array(numValues);\n          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n          onAttributeData(kind, babylonData);\n        }\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n\n    if (attributes) {\n      for (var kind in attributes) {\n        var id = attributes[kind];\n        var attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        processAttribute(kind, attribute);\n      }\n    } else {\n      var nativeAttributeTypes = {\n        \"position\": \"POSITION\",\n        \"normal\": \"NORMAL\",\n        \"color\": \"COLOR\",\n        \"uv\": \"TEX_COORD\"\n      };\n\n      for (var kind in nativeAttributeTypes) {\n        var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n\n        if (id !== -1) {\n          var attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(kind, attribute);\n        }\n      }\n    }\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(buffer);\n  }\n}\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\n\n\nfunction worker() {\n  var decoderPromise;\n\n  onmessage = function (event) {\n    var data = event.data;\n\n    switch (data.id) {\n      case \"init\":\n        {\n          var decoder = data.decoder;\n\n          if (decoder.url) {\n            importScripts(decoder.url);\n            decoderPromise = DracoDecoderModule({\n              wasmBinary: decoder.wasmBinary\n            });\n          }\n\n          postMessage(\"done\");\n          break;\n        }\n\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n\n          decoderPromise.then(function (decoder) {\n            decodeMesh(decoder, data.dataView, data.attributes, function (indices) {\n              postMessage({\n                id: \"indices\",\n                value: indices\n              }, [indices.buffer]);\n            }, function (kind, data) {\n              postMessage({\n                id: kind,\n                value: data\n              }, [data.buffer]);\n            });\n            postMessage(\"done\");\n          });\n          break;\n        }\n    }\n  };\n}\n\nfunction getAbsoluteUrl(url) {\n  if (typeof document !== \"object\" || typeof url !== \"string\") {\n    return url;\n  }\n\n  return Tools.GetAbsoluteUrl(url);\n}\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\n\n\nvar DracoCompression =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n   */\n  function DracoCompression(numWorkers) {\n    if (numWorkers === void 0) {\n      numWorkers = DracoCompression.DefaultNumWorkers;\n    }\n\n    var decoder = DracoCompression.Configuration.decoder;\n    var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" ? {\n      url: decoder.wasmUrl,\n      wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))\n    } : {\n      url: decoder.fallbackUrl,\n      wasmBinaryPromise: Promise.resolve(undefined)\n    };\n\n    if (numWorkers && typeof Worker === \"function\") {\n      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        var workerContent = decodeMesh + \"(\" + worker + \")()\";\n        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        var workerPromises = new Array(numWorkers);\n\n        for (var i = 0; i < workerPromises.length; i++) {\n          workerPromises[i] = new Promise(function (resolve, reject) {\n            var worker = new Worker(workerBlobUrl);\n\n            var onError = function (error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n\n            var onMessage = function (message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              id: \"init\",\n              decoder: {\n                url: getAbsoluteUrl(decoderInfo.url),\n                wasmBinary: decoderWasmBinary\n              }\n            });\n          });\n        }\n\n        return Promise.all(workerPromises).then(function (workers) {\n          return new WorkerPool(workers);\n        });\n      });\n    } else {\n      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        if (!decoderInfo.url) {\n          throw new Error(\"Draco decoder module is not available\");\n        }\n\n        return Tools.LoadScriptAsync(decoderInfo.url).then(function () {\n          return createDecoderAsync(decoderWasmBinary);\n        });\n      });\n    }\n  }\n\n  Object.defineProperty(DracoCompression, \"DecoderAvailable\", {\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\n    get: function () {\n      var decoder = DracoCompression.Configuration.decoder;\n      return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" || decoder.fallbackUrl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DracoCompression.GetDefaultNumWorkers = function () {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    } // Use 50% of the available logical processors but capped at 4.\n\n\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  };\n\n  Object.defineProperty(DracoCompression, \"Default\", {\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\n    get: function () {\n      if (!DracoCompression._Default) {\n        DracoCompression._Default = new DracoCompression();\n      }\n\n      return DracoCompression._Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stop all async operations and release resources.\r\n   */\n\n  DracoCompression.prototype.dispose = function () {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(function (workerPool) {\n        workerPool.dispose();\n      });\n    }\n\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  };\n  /**\r\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n   * @returns a promise that resolves when ready\r\n   */\n\n\n  DracoCompression.prototype.whenReadyAsync = function () {\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function () {});\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function () {});\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n    * Decode Draco compressed mesh data to vertex data.\r\n    * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n    * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n    * @returns A promise that resolves with the decoded vertex data\r\n    */\n\n\n  DracoCompression.prototype.decodeMeshAsync = function (data, attributes) {\n    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function (workerPool) {\n        return new Promise(function (resolve, reject) {\n          workerPool.push(function (worker, onComplete) {\n            var vertexData = new VertexData();\n\n            var onError = function (error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n\n            var onMessage = function (message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(vertexData);\n                onComplete();\n              } else if (message.data.id === \"indices\") {\n                vertexData.indices = message.data.value;\n              } else {\n                vertexData.set(message.data.value, message.data.id);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            var dataViewCopy = new Uint8Array(dataView.byteLength);\n            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function (decoder) {\n        var vertexData = new VertexData();\n        decodeMesh(decoder.module, dataView, attributes, function (indices) {\n          vertexData.indices = indices;\n        }, function (kind, data) {\n          vertexData.set(data, kind);\n        });\n        return vertexData;\n      });\n    }\n\n    throw new Error(\"Draco decoder module is not available\");\n  };\n  /**\r\n   * The configuration. Defaults to the following urls:\r\n   * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n   * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n   * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n   */\n\n\n  DracoCompression.Configuration = {\n    decoder: {\n      wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n      wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n      fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n    }\n  };\n  /**\r\n   * Default number of workers to create when creating the draco compression object.\r\n   */\n\n  DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\n  DracoCompression._Default = null;\n  return DracoCompression;\n}();\n\nexport { DracoCompression };","map":{"version":3,"sources":["C:/Users/rober/Documents/Computer Science/Side Projects/arcade/node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js"],"names":["Tools","WorkerPool","VertexData","createDecoderAsync","wasmBinary","Promise","resolve","DracoDecoderModule","then","module","decodeMesh","decoderModule","dataView","attributes","onIndicesData","onAttributeData","buffer","DecoderBuffer","Init","byteLength","decoder","Decoder","geometry","status","type","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","error_msg","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","indices","Uint32Array","set","HEAPF32","_free","processAttribute","kind","attribute","numComponents","num_components","numPoints","num_points","numValues","Float32Array","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","DT_FLOAT32","values","babylonData","i","j","length","id","GetAttributeByUniqueId","nativeAttributeTypes","GetAttributeId","GetAttribute","destroy","worker","decoderPromise","onmessage","event","data","url","importScripts","postMessage","value","getAbsoluteUrl","document","GetAbsoluteUrl","DracoCompression","numWorkers","DefaultNumWorkers","Configuration","decoderInfo","wasmUrl","wasmBinaryUrl","WebAssembly","wasmBinaryPromise","LoadFileAsync","fallbackUrl","undefined","Worker","_workerPoolPromise","decoderWasmBinary","workerContent","workerBlobUrl","URL","createObjectURL","Blob","workerPromises","Array","reject","onError","error","removeEventListener","onMessage","message","addEventListener","all","workers","_decoderModulePromise","LoadScriptAsync","Object","defineProperty","get","enumerable","configurable","GetDefaultNumWorkers","navigator","hardwareConcurrency","Math","min","floor","_Default","prototype","dispose","workerPool","whenReadyAsync","decodeMeshAsync","ArrayBuffer","Uint8Array","push","onComplete","vertexData","dataViewCopy","byteOffset"],"mappings":"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","sourcesContent":["import { Tools } from \"../../Misc/tools\";\r\nimport { WorkerPool } from '../../Misc/workerPool';\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nfunction createDecoderAsync(wasmBinary) {\r\n    return new Promise(function (resolve) {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then(function (module) {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData) {\r\n    var buffer = new decoderModule.DecoderBuffer();\r\n    buffer.Init(dataView, dataView.byteLength);\r\n    var decoder = new decoderModule.Decoder();\r\n    var geometry;\r\n    var status;\r\n    try {\r\n        var type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH:\r\n                geometry = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\r\n                break;\r\n            case decoderModule.POINT_CLOUD:\r\n                geometry = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\r\n                break;\r\n            default:\r\n                throw new Error(\"Invalid geometry type \" + type);\r\n        }\r\n        if (!status.ok() || !geometry.ptr) {\r\n            throw new Error(status.error_msg());\r\n        }\r\n        if (type === decoderModule.TRIANGULAR_MESH) {\r\n            var numFaces = geometry.num_faces();\r\n            var numIndices = numFaces * 3;\r\n            var byteLength = numIndices * 4;\r\n            var ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\r\n                var indices = new Uint32Array(numIndices);\r\n                indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                onIndicesData(indices);\r\n            }\r\n            finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        }\r\n        var processAttribute = function (kind, attribute) {\r\n            var numComponents = attribute.num_components();\r\n            var numPoints = geometry.num_points();\r\n            var numValues = numPoints * numComponents;\r\n            var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n            var ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\r\n                var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\r\n                if (kind === \"color\" && numComponents === 3) {\r\n                    var babylonData = new Float32Array(numPoints * 4);\r\n                    for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\r\n                        babylonData[i + 0] = values[j + 0];\r\n                        babylonData[i + 1] = values[j + 1];\r\n                        babylonData[i + 2] = values[j + 2];\r\n                        babylonData[i + 3] = 1;\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n                else {\r\n                    var babylonData = new Float32Array(numValues);\r\n                    babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n            }\r\n            finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n        if (attributes) {\r\n            for (var kind in attributes) {\r\n                var id = attributes[kind];\r\n                var attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(kind, attribute);\r\n            }\r\n        }\r\n        else {\r\n            var nativeAttributeTypes = {\r\n                \"position\": \"POSITION\",\r\n                \"normal\": \"NORMAL\",\r\n                \"color\": \"COLOR\",\r\n                \"uv\": \"TEX_COORD\"\r\n            };\r\n            for (var kind in nativeAttributeTypes) {\r\n                var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\r\n                if (id !== -1) {\r\n                    var attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(kind, attribute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n        decoderModule.destroy(decoder);\r\n        decoderModule.destroy(buffer);\r\n    }\r\n}\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker() {\r\n    var decoderPromise;\r\n    onmessage = function (event) {\r\n        var data = event.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                var decoder = data.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage(\"done\");\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then(function (decoder) {\r\n                    decodeMesh(decoder, data.dataView, data.attributes, function (indices) {\r\n                        postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\r\n                    }, function (kind, data) {\r\n                        postMessage({ id: kind, value: data }, [data.buffer]);\r\n                    });\r\n                    postMessage(\"done\");\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction getAbsoluteUrl(url) {\r\n    if (typeof document !== \"object\" || typeof url !== \"string\") {\r\n        return url;\r\n    }\r\n    return Tools.GetAbsoluteUrl(url);\r\n}\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\r\nvar DracoCompression = /** @class */ (function () {\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    function DracoCompression(numWorkers) {\r\n        if (numWorkers === void 0) { numWorkers = DracoCompression.DefaultNumWorkers; }\r\n        var decoder = DracoCompression.Configuration.decoder;\r\n        var decoderInfo = (decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") ? {\r\n            url: decoder.wasmUrl,\r\n            wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))\r\n        } : {\r\n            url: decoder.fallbackUrl,\r\n            wasmBinaryPromise: Promise.resolve(undefined)\r\n        };\r\n        if (numWorkers && typeof Worker === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\r\n                var workerContent = decodeMesh + \"(\" + worker + \")()\";\r\n                var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                var workerPromises = new Array(numWorkers);\r\n                for (var i = 0; i < workerPromises.length; i++) {\r\n                    workerPromises[i] = new Promise(function (resolve, reject) {\r\n                        var worker = new Worker(workerBlobUrl);\r\n                        var onError = function (error) {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n                        var onMessage = function (message) {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: getAbsoluteUrl(decoderInfo.url),\r\n                                wasmBinary: decoderWasmBinary,\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                return Promise.all(workerPromises).then(function (workers) {\r\n                    return new WorkerPool(workers);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                return Tools.LoadScriptAsync(decoderInfo.url).then(function () {\r\n                    return createDecoderAsync(decoderWasmBinary);\r\n                });\r\n            });\r\n        }\r\n    }\r\n    Object.defineProperty(DracoCompression, \"DecoderAvailable\", {\r\n        /**\r\n         * Returns true if the decoder configuration is available.\r\n         */\r\n        get: function () {\r\n            var decoder = DracoCompression.Configuration.decoder;\r\n            return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    DracoCompression.GetDefaultNumWorkers = function () {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    };\r\n    Object.defineProperty(DracoCompression, \"Default\", {\r\n        /**\r\n         * Default instance for the draco compression object.\r\n         */\r\n        get: function () {\r\n            if (!DracoCompression._Default) {\r\n                DracoCompression._Default = new DracoCompression();\r\n            }\r\n            return DracoCompression._Default;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    DracoCompression.prototype.dispose = function () {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then(function (workerPool) {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    };\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    DracoCompression.prototype.whenReadyAsync = function () {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(function () { });\r\n        }\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(function () { });\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    /**\r\n      * Decode Draco compressed mesh data to vertex data.\r\n      * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n      * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n      * @returns A promise that resolves with the decoded vertex data\r\n      */\r\n    DracoCompression.prototype.decodeMeshAsync = function (data, attributes) {\r\n        var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(function (workerPool) {\r\n                return new Promise(function (resolve, reject) {\r\n                    workerPool.push(function (worker, onComplete) {\r\n                        var vertexData = new VertexData();\r\n                        var onError = function (error) {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n                        var onMessage = function (message) {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(vertexData);\r\n                                onComplete();\r\n                            }\r\n                            else if (message.data.id === \"indices\") {\r\n                                vertexData.indices = message.data.value;\r\n                            }\r\n                            else {\r\n                                vertexData.set(message.data.value, message.data.id);\r\n                            }\r\n                        };\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n                        var dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(function (decoder) {\r\n                var vertexData = new VertexData();\r\n                decodeMesh(decoder.module, dataView, attributes, function (indices) {\r\n                    vertexData.indices = indices;\r\n                }, function (kind, data) {\r\n                    vertexData.set(data, kind);\r\n                });\r\n                return vertexData;\r\n            });\r\n        }\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    };\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    DracoCompression.Configuration = {\r\n        decoder: {\r\n            wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\r\n            wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\r\n            fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n        }\r\n    };\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n    DracoCompression._Default = null;\r\n    return DracoCompression;\r\n}());\r\nexport { DracoCompression };\r\n"]},"metadata":{},"sourceType":"module"}