{"ast":null,"code":"import { Engine } from \"../../../Engines/engine\";\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\nimport { Texture } from \"../texture\";\nimport { DynamicTexture } from \"../dynamicTexture\";\nimport { Vector2 } from \"../../../Maths/math.vector\";\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\nimport { TexturePackerFrame } from \"./frame\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { Tools } from '../../../Misc/tools';\n/**\r\n* This is a support class that generates a series of packed texture sets.\r\n* @see https://doc.babylonjs.com/babylon101/materials\r\n*/\n\nvar TexturePacker =\n/** @class */\nfunction () {\n  /**\r\n  * Initializes a texture package series from an array of meshes or a single mesh.\r\n  * @param name The name of the package\r\n  * @param meshes The target meshes to compose the package from\r\n  * @param options The arguments that texture packer should follow while building.\r\n  * @param scene The scene which the textures are scoped to.\r\n  * @returns TexturePacker\r\n  */\n  function TexturePacker(name, meshes, options, scene) {\n    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.name = name;\n    this.meshes = meshes;\n    this.scene = scene;\n    /**\r\n     * Run through the options and set what ever defaults are needed that where not declared.\r\n     */\n\n    this.options = options;\n    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : ['ambientTexture', 'bumpTexture', 'diffuseTexture', 'emissiveTexture', 'lightmapTexture', 'opacityTexture', 'reflectionTexture', 'refractionTexture', 'specularTexture'];\n    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\n    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\n    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\n\n    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\n    }\n\n    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\n    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\n    this._expecting = 0;\n    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\n\n    if (this.options.fillBlanks === true) {\n      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : 'black';\n    }\n\n    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\n    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\n    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio); //Make it an even padding Number.\n\n    if (this._paddingValue % 2 !== 0) {\n      this._paddingValue++;\n    }\n\n    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\n\n    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\n    }\n\n    this.sets = {};\n    this.frames = [];\n    return this;\n  }\n  /**\r\n  * Starts the package process\r\n  * @param resolve The promises resolution function\r\n  * @returns TexturePacker\r\n  */\n\n\n  TexturePacker.prototype._createFrames = function (resolve) {\n    var _this = this;\n\n    var dtSize = this._calculateSize();\n\n    var dtUnits = new Vector2(1, 1).divide(dtSize);\n    var doneCount = 0;\n    var expecting = this._expecting;\n    var meshLength = this.meshes.length;\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n      var dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set', {\n        width: dtSize.x,\n        height: dtSize.y\n      }, this.scene, true, //Generate Mips\n      Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n      var dtx = dt.getContext();\n      dtx.fillStyle = 'rgba(0,0,0,0)';\n      dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n      dt.update(false);\n      this.sets[setName] = dt;\n    }\n\n    var baseSize = this.options.frameSize || 256;\n    var padding = this._paddingValue;\n    var tcs = baseSize + 2 * padding;\n\n    var done = function () {\n      _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);\n    }; //Update the Textures\n\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var mat = m.material;\n\n      var _loop_1 = function (j) {\n        var tempTexture = new DynamicTexture('temp', tcs, this_1.scene, true);\n        var tcx = tempTexture.getContext();\n\n        var offset = this_1._getFrameOffset(i);\n\n        var updateDt = function () {\n          doneCount++;\n          tempTexture.update(false);\n          var iDat = tcx.getImageData(0, 0, tcs, tcs); //Update Set\n\n          var dt = _this.sets[setName];\n          var dtx = dt.getContext();\n          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n          tempTexture.dispose();\n          dt.update(false);\n\n          if (doneCount == expecting) {\n            done();\n            resolve();\n            return;\n          }\n        };\n\n        var setName = sKeys[j] || '_blank';\n\n        if (!mat || mat[setName] === null) {\n          tcx.fillStyle = 'rgba(0,0,0,0)';\n\n          if (this_1.options.fillBlanks) {\n            tcx.fillStyle = this_1.options.customFillColor;\n          }\n\n          tcx.fillRect(0, 0, tcs, tcs);\n          updateDt();\n        } else {\n          var setTexture = mat[setName];\n          var img_1 = new Image();\n\n          if (setTexture instanceof DynamicTexture) {\n            img_1.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n          } else {\n            img_1.src = setTexture.url;\n          }\n\n          Tools.SetCorsBehavior(img_1.src, img_1);\n\n          img_1.onload = function () {\n            tcx.fillStyle = 'rgba(0,0,0,0)';\n            tcx.fillRect(0, 0, tcs, tcs);\n            tempTexture.update(false);\n            tcx.setTransform(1, 0, 0, -1, 0, 0);\n            var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n\n            switch (_this.options.paddingMode) {\n              //Wrap Mode\n              case 0:\n                for (var i_1 = 0; i_1 < 9; i_1++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[i_1], padding + baseSize * cellOffsets[i_1 + 1] - tcs, baseSize, baseSize);\n                }\n\n                break;\n              //Extend Mode\n\n              case 1:\n                for (var i_2 = 0; i_2 < padding; i_2++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding * 2 - i_2, padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, padding * 2 - i_2 - tcs, baseSize, baseSize);\n                }\n\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n              //Color Mode\n\n              case 2:\n                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();\n                tcx.fillRect(0, 0, tcs, -tcs);\n                tcx.clearRect(padding, padding, baseSize, baseSize);\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n            }\n\n            tcx.setTransform(1, 0, 0, 1, 0, 0);\n            updateDt();\n          };\n        }\n      };\n\n      var this_1 = this; //Check if the material has the texture\n      //Create a temporary canvas the same size as 1 frame\n      //Then apply the texture to the center and the 8 offsets\n      //Copy the Context and place in the correct frame on the DT\n\n      for (var j = 0; j < sKeys.length; j++) {\n        _loop_1(j);\n      }\n    }\n  };\n  /**\r\n  * Calculates the Size of the Channel Sets\r\n  * @returns Vector2\r\n  */\n\n\n  TexturePacker.prototype._calculateSize = function () {\n    var meshLength = this.meshes.length || 0;\n    var baseSize = this.options.frameSize || 0;\n    var padding = this._paddingValue || 0;\n\n    switch (this.options.layout) {\n      case 0:\n        //STRIP_LAYOUT\n        return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n        break;\n\n      case 1:\n        //POWER2\n        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n        var size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n        return new Vector2(size, size);\n        break;\n\n      case 2:\n        //COLNUM\n        var cols = this.options.colnum || 1;\n        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n        return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n        break;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n  * Calculates the UV data for the frames.\r\n  * @param baseSize the base frameSize\r\n  * @param padding the base frame padding\r\n  * @param dtSize size of the Dynamic Texture for that channel\r\n  * @param dtUnits is 1/dtSize\r\n  * @param update flag to update the input meshes\r\n  */\n\n\n  TexturePacker.prototype._calculateMeshUVFrames = function (baseSize, padding, dtSize, dtUnits, update) {\n    var meshLength = this.meshes.length;\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n      var pOffset = dtUnits.clone().scale(padding);\n\n      var frameOffset = this._getFrameOffset(i);\n\n      var offset = frameOffset.add(pOffset);\n      var frame = new TexturePackerFrame(i, scale, offset);\n      this.frames.push(frame); //Update Output UVs\n\n      if (update) {\n        this._updateMeshUV(m, i);\n\n        this._updateTextureReferences(m);\n      }\n    }\n  };\n  /**\r\n  * Calculates the frames Offset.\r\n  * @param index of the frame\r\n  * @returns Vector2\r\n  */\n\n\n  TexturePacker.prototype._getFrameOffset = function (index) {\n    var meshLength = this.meshes.length;\n    var uvStep, yStep, xStep;\n\n    switch (this.options.layout) {\n      case 0:\n        //STRIP_LAYOUT\n        uvStep = 1 / meshLength;\n        return new Vector2(index * uvStep, 0);\n        break;\n\n      case 1:\n        //POWER2\n        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n        yStep = Math.floor(index / sqrtCount);\n        xStep = index - yStep * sqrtCount;\n        uvStep = 1 / sqrtCount;\n        return new Vector2(xStep * uvStep, yStep * uvStep);\n        break;\n\n      case 2:\n        //COLNUM\n        var cols = this.options.colnum || 1;\n        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n        xStep = Math.floor(index / rowCnt);\n        yStep = index - xStep * rowCnt;\n        uvStep = new Vector2(1 / cols, 1 / rowCnt);\n        return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n        break;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n  * Updates a Mesh to the frame data\r\n  * @param mesh that is the target\r\n  * @param frameID or the frame index\r\n  */\n\n\n  TexturePacker.prototype._updateMeshUV = function (mesh, frameID) {\n    var frame = this.frames[frameID];\n    var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n    var uvOut = [];\n    var toCount = 0;\n\n    if (uvIn.length) {\n      toCount = uvIn.length || 0;\n    }\n\n    for (var i = 0; i < toCount; i += 2) {\n      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n    }\n\n    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n  };\n  /**\r\n  * Updates a Meshes materials to use the texture packer channels\r\n  * @param m is the mesh to target\r\n  * @param force all channels on the packer to be set.\r\n  */\n\n\n  TexturePacker.prototype._updateTextureReferences = function (m, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    var mat = m.material;\n    var sKeys = Object.keys(this.sets);\n\n    var _dispose = function (_t) {\n      if (_t.dispose) {\n        _t.dispose();\n      }\n    };\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n\n      if (!force) {\n        if (!mat) {\n          return;\n        }\n\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n\n          mat[setName] = this.sets[setName];\n        }\n      } else {\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n        }\n\n        mat[setName] = this.sets[setName];\n      }\n    }\n  };\n  /**\r\n  * Public method to set a Mesh to a frame\r\n  * @param m that is the target\r\n  * @param frameID or the frame index\r\n  * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n  */\n\n\n  TexturePacker.prototype.setMeshToFrame = function (m, frameID, updateMaterial) {\n    if (updateMaterial === void 0) {\n      updateMaterial = false;\n    }\n\n    this._updateMeshUV(m, frameID);\n\n    if (updateMaterial) {\n      this._updateTextureReferences(m, true);\n    }\n  };\n  /**\r\n  * Starts the async promise to compile the texture packer.\r\n  * @returns Promise<void>\r\n  */\n\n\n  TexturePacker.prototype.processAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.meshes.length === 0) {\n          //Must be a JSON load!\n          resolve();\n          return;\n        }\n\n        var done_1 = 0;\n\n        var doneCheck_1 = function (mat) {\n          done_1++; //Check Status of all Textures on all meshes, till they are ready.\n\n          if (_this.options.map) {\n            for (var j = 0; j < _this.options.map.length; j++) {\n              var index = _this.options.map[j];\n              var t = mat[index];\n\n              if (t !== null) {\n                if (!_this.sets[_this.options.map[j]]) {\n                  _this.sets[_this.options.map[j]] = true;\n                }\n\n                _this._expecting++;\n              }\n            }\n\n            if (done_1 === _this.meshes.length) {\n              _this._createFrames(resolve);\n            }\n          }\n        };\n\n        var _loop_2 = function (i) {\n          var mesh = _this.meshes[i];\n          var material = mesh.material;\n\n          if (!material) {\n            done_1++;\n\n            if (done_1 === _this.meshes.length) {\n              return {\n                value: _this._createFrames(resolve)\n              };\n            }\n\n            return \"continue\";\n          }\n\n          material.forceCompilationAsync(mesh).then(function () {\n            doneCheck_1(material);\n          });\n        };\n\n        for (var i = 0; i < _this.meshes.length; i++) {\n          var state_1 = _loop_2(i);\n\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\r\n  * Disposes all textures associated with this packer\r\n  */\n\n\n  TexturePacker.prototype.dispose = function () {\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var channel = sKeys[i];\n      this.sets[channel].dispose();\n    }\n  };\n  /**\r\n  * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n  * @param imageType is the image type to use.\r\n  * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n  */\n\n\n  TexturePacker.prototype.download = function (imageType, quality) {\n    var _this = this;\n\n    if (imageType === void 0) {\n      imageType = 'png';\n    }\n\n    if (quality === void 0) {\n      quality = 1;\n    }\n\n    setTimeout(function () {\n      var pack = {\n        name: _this.name,\n        sets: {},\n        options: {},\n        frames: []\n      };\n      var sKeys = Object.keys(_this.sets);\n      var oKeys = Object.keys(_this.options);\n\n      try {\n        for (var i = 0; i < sKeys.length; i++) {\n          var channel = sKeys[i];\n          var dt = _this.sets[channel];\n          pack.sets[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);\n        }\n\n        for (var i = 0; i < oKeys.length; i++) {\n          var opt = oKeys[i];\n          pack.options[opt] = _this.options[opt];\n        }\n\n        for (var i = 0; i < _this.frames.length; i++) {\n          var _f = _this.frames[i];\n          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n        }\n      } catch (err) {\n        Logger.Warn(\"Unable to download: \" + err);\n        return;\n      }\n\n      var data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n\n      var _a = document.createElement('a');\n\n      _a.setAttribute(\"href\", data);\n\n      _a.setAttribute(\"download\", _this.name + \"_texurePackage.json\");\n\n      document.body.appendChild(_a);\n\n      _a.click();\n\n      _a.remove();\n    }, 0);\n  };\n  /**\r\n  * Public method to load a texturePacker JSON file.\r\n  * @param data of the JSON file in string format.\r\n  */\n\n\n  TexturePacker.prototype.updateFromJSON = function (data) {\n    try {\n      var parsedData = JSON.parse(data);\n      this.name = parsedData.name;\n\n      var _options = Object.keys(parsedData.options);\n\n      for (var i = 0; i < _options.length; i++) {\n        this.options[_options[i]] = parsedData.options[_options[i]];\n      }\n\n      for (var i = 0; i < parsedData.frames.length; i += 4) {\n        var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n        this.frames.push(frame);\n      }\n\n      var channels = Object.keys(parsedData.sets);\n\n      for (var i = 0; i < channels.length; i++) {\n        var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n\n        this.sets[channels[i]] = _t;\n      }\n    } catch (err) {\n      Logger.Warn(\"Unable to update from JSON: \" + err);\n    }\n  };\n  /** Packer Layout Constant 0 */\n\n\n  TexturePacker.LAYOUT_STRIP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.LAYOUT_POWER2 = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.LAYOUT_COLNUM = 2;\n  /** Packer Layout Constant 0 */\n\n  TexturePacker.SUBUV_WRAP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.SUBUV_EXTEND = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.SUBUV_COLOR = 2;\n  return TexturePacker;\n}();\n\nexport { TexturePacker };","map":{"version":3,"sources":["C:/Users/rober/Documents/Computer Science/Side Projects/arcade/node_modules/@babylonjs/core/Materials/Textures/Packer/packer.js"],"names":["Engine","VertexBuffer","Texture","DynamicTexture","Vector2","Color3","Color4","TexturePackerFrame","Logger","Tools","TexturePacker","name","meshes","options","scene","_b","_c","_d","_e","_g","_h","_j","_k","_l","_m","_o","_p","_q","map","uvsIn","UVKind","uvsOut","layout","LAYOUT_STRIP","LAYOUT_COLNUM","colnum","updateInputMeshes","disposeSources","_expecting","fillBlanks","customFillColor","frameSize","paddingRatio","_paddingValue","Math","ceil","paddingMode","SUBUV_WRAP","SUBUV_COLOR","paddingColor","sets","frames","prototype","_createFrames","resolve","_this","dtSize","_calculateSize","dtUnits","divide","doneCount","expecting","meshLength","length","sKeys","Object","keys","i","setName","dt","width","x","height","y","TRILINEAR_SAMPLINGMODE","TEXTUREFORMAT_RGBA","dtx","getContext","fillStyle","fillRect","update","baseSize","padding","tcs","done","_calculateMeshUVFrames","m","mat","material","_loop_1","j","tempTexture","this_1","tcx","offset","_getFrameOffset","updateDt","iDat","getImageData","putImageData","dispose","setTexture","img_1","Image","src","canvas","toDataURL","url","SetCorsBehavior","onload","setTransform","cellOffsets","i_1","drawImage","i_2","Black","toHexString","clearRect","sqrtCount","max","sqrt","size","cols","rowCnt","Zero","scale","pOffset","clone","frameOffset","add","frame","push","_updateMeshUV","_updateTextureReferences","index","uvStep","yStep","xStep","floor","mesh","frameID","uvIn","getVerticesData","uvOut","toCount","setVerticesData","force","_dispose","_t","setMeshToFrame","updateMaterial","processAsync","Promise","reject","done_1","doneCheck_1","t","_loop_2","value","forceCompilationAsync","then","state_1","e","channel","download","imageType","quality","setTimeout","pack","oKeys","opt","_f","err","Warn","data","encodeURIComponent","JSON","stringify","_a","document","createElement","setAttribute","body","appendChild","click","remove","updateFromJSON","parsedData","parse","_options","channels","LAYOUT_POWER2","SUBUV_EXTEND"],"mappings":"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","sourcesContent":["import { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\r\nimport { Texture } from \"../texture\";\r\nimport { DynamicTexture } from \"../dynamicTexture\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\r\nimport { TexturePackerFrame } from \"./frame\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Tools } from '../../../Misc/tools';\r\n/**\r\n* This is a support class that generates a series of packed texture sets.\r\n* @see https://doc.babylonjs.com/babylon101/materials\r\n*/\r\nvar TexturePacker = /** @class */ (function () {\r\n    /**\r\n    * Initializes a texture package series from an array of meshes or a single mesh.\r\n    * @param name The name of the package\r\n    * @param meshes The target meshes to compose the package from\r\n    * @param options The arguments that texture packer should follow while building.\r\n    * @param scene The scene which the textures are scoped to.\r\n    * @returns TexturePacker\r\n    */\r\n    function TexturePacker(name, meshes, options, scene) {\r\n        var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\r\n        this.name = name;\r\n        this.meshes = meshes;\r\n        this.scene = scene;\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : [\r\n            'ambientTexture',\r\n            'bumpTexture',\r\n            'diffuseTexture',\r\n            'emissiveTexture',\r\n            'lightmapTexture',\r\n            'opacityTexture',\r\n            'reflectionTexture',\r\n            'refractionTexture',\r\n            'specularTexture'\r\n        ];\r\n        this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\r\n        this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\r\n        this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\r\n        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\r\n            this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\r\n        }\r\n        this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\r\n        this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\r\n        this._expecting = 0;\r\n        this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\r\n        if (this.options.fillBlanks === true) {\r\n            this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : 'black';\r\n        }\r\n        this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\r\n        this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\r\n        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\r\n        //Make it an even padding Number.\r\n        if (this._paddingValue % 2 !== 0) {\r\n            this._paddingValue++;\r\n        }\r\n        this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\r\n        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\r\n            this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\r\n        }\r\n        this.sets = {};\r\n        this.frames = [];\r\n        return this;\r\n    }\r\n    /**\r\n    * Starts the package process\r\n    * @param resolve The promises resolution function\r\n    * @returns TexturePacker\r\n    */\r\n    TexturePacker.prototype._createFrames = function (resolve) {\r\n        var _this = this;\r\n        var dtSize = this._calculateSize();\r\n        var dtUnits = (new Vector2(1, 1)).divide(dtSize);\r\n        var doneCount = 0;\r\n        var expecting = this._expecting;\r\n        var meshLength = this.meshes.length;\r\n        var sKeys = Object.keys(this.sets);\r\n        for (var i = 0; i < sKeys.length; i++) {\r\n            var setName = sKeys[i];\r\n            var dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set', { width: dtSize.x, height: dtSize.y }, this.scene, true, //Generate Mips\r\n            Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\r\n            var dtx = dt.getContext();\r\n            dtx.fillStyle = 'rgba(0,0,0,0)';\r\n            dtx.fillRect(0, 0, dtSize.x, dtSize.y);\r\n            dt.update(false);\r\n            this.sets[setName] = dt;\r\n        }\r\n        var baseSize = this.options.frameSize || 256;\r\n        var padding = this._paddingValue;\r\n        var tcs = baseSize + (2 * padding);\r\n        var done = function () {\r\n            _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);\r\n        };\r\n        //Update the Textures\r\n        for (var i = 0; i < meshLength; i++) {\r\n            var m = this.meshes[i];\r\n            var mat = m.material;\r\n            var _loop_1 = function (j) {\r\n                var tempTexture = new DynamicTexture('temp', tcs, this_1.scene, true);\r\n                var tcx = tempTexture.getContext();\r\n                var offset = this_1._getFrameOffset(i);\r\n                var updateDt = function () {\r\n                    doneCount++;\r\n                    tempTexture.update(false);\r\n                    var iDat = tcx.getImageData(0, 0, tcs, tcs);\r\n                    //Update Set\r\n                    var dt = _this.sets[setName];\r\n                    var dtx = dt.getContext();\r\n                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\r\n                    tempTexture.dispose();\r\n                    dt.update(false);\r\n                    if (doneCount == expecting) {\r\n                        done();\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                };\r\n                var setName = sKeys[j] || '_blank';\r\n                if (!mat || mat[setName] === null) {\r\n                    tcx.fillStyle = 'rgba(0,0,0,0)';\r\n                    if (this_1.options.fillBlanks) {\r\n                        tcx.fillStyle = this_1.options.customFillColor;\r\n                    }\r\n                    tcx.fillRect(0, 0, tcs, tcs);\r\n                    updateDt();\r\n                }\r\n                else {\r\n                    var setTexture = mat[setName];\r\n                    var img_1 = new Image();\r\n                    if (setTexture instanceof DynamicTexture) {\r\n                        img_1.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\r\n                    }\r\n                    else {\r\n                        img_1.src = setTexture.url;\r\n                    }\r\n                    Tools.SetCorsBehavior(img_1.src, img_1);\r\n                    img_1.onload = function () {\r\n                        tcx.fillStyle = 'rgba(0,0,0,0)';\r\n                        tcx.fillRect(0, 0, tcs, tcs);\r\n                        tempTexture.update(false);\r\n                        tcx.setTransform(1, 0, 0, -1, 0, 0);\r\n                        var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\r\n                        switch (_this.options.paddingMode) {\r\n                            //Wrap Mode\r\n                            case 0:\r\n                                for (var i_1 = 0; i_1 < 9; i_1++) {\r\n                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding) + (baseSize * cellOffsets[i_1]), ((padding) + (baseSize * cellOffsets[i_1 + 1])) - tcs, baseSize, baseSize);\r\n                                }\r\n                                break;\r\n                            //Extend Mode\r\n                            case 1:\r\n                                for (var i_2 = 0; i_2 < padding; i_2++) {\r\n                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + (baseSize * cellOffsets[0]), padding - tcs, baseSize, baseSize);\r\n                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding * 2) - i_2, padding - tcs, baseSize, baseSize);\r\n                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);\r\n                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, (padding * 2) - i_2 - tcs, baseSize, baseSize);\r\n                                }\r\n                                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding) + (baseSize * cellOffsets[0]), ((padding) + (baseSize * cellOffsets[1])) - tcs, baseSize, baseSize);\r\n                                break;\r\n                            //Color Mode\r\n                            case 2:\r\n                                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();\r\n                                tcx.fillRect(0, 0, tcs, -tcs);\r\n                                tcx.clearRect(padding, padding, baseSize, baseSize);\r\n                                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding) + (baseSize * cellOffsets[0]), ((padding) + (baseSize * cellOffsets[1])) - tcs, baseSize, baseSize);\r\n                                break;\r\n                        }\r\n                        tcx.setTransform(1, 0, 0, 1, 0, 0);\r\n                        updateDt();\r\n                    };\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            //Check if the material has the texture\r\n            //Create a temporary canvas the same size as 1 frame\r\n            //Then apply the texture to the center and the 8 offsets\r\n            //Copy the Context and place in the correct frame on the DT\r\n            for (var j = 0; j < sKeys.length; j++) {\r\n                _loop_1(j);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n    * Calculates the Size of the Channel Sets\r\n    * @returns Vector2\r\n    */\r\n    TexturePacker.prototype._calculateSize = function () {\r\n        var meshLength = this.meshes.length || 0;\r\n        var baseSize = this.options.frameSize || 0;\r\n        var padding = this._paddingValue || 0;\r\n        switch (this.options.layout) {\r\n            case 0:\r\n                //STRIP_LAYOUT\r\n                return new Vector2((baseSize * meshLength) + (2 * padding * meshLength), (baseSize) + (2 * padding));\r\n                break;\r\n            case 1:\r\n                //POWER2\r\n                var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                var size = (baseSize * sqrtCount) + (2 * padding * sqrtCount);\r\n                return new Vector2(size, size);\r\n                break;\r\n            case 2:\r\n                //COLNUM\r\n                var cols = this.options.colnum || 1;\r\n                var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                return new Vector2((baseSize * cols) + (2 * padding * cols), (baseSize * rowCnt) + (2 * padding * rowCnt));\r\n                break;\r\n        }\r\n        return Vector2.Zero();\r\n    };\r\n    /**\r\n    * Calculates the UV data for the frames.\r\n    * @param baseSize the base frameSize\r\n    * @param padding the base frame padding\r\n    * @param dtSize size of the Dynamic Texture for that channel\r\n    * @param dtUnits is 1/dtSize\r\n    * @param update flag to update the input meshes\r\n    */\r\n    TexturePacker.prototype._calculateMeshUVFrames = function (baseSize, padding, dtSize, dtUnits, update) {\r\n        var meshLength = this.meshes.length;\r\n        for (var i = 0; i < meshLength; i++) {\r\n            var m = this.meshes[i];\r\n            var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\r\n            var pOffset = dtUnits.clone().scale(padding);\r\n            var frameOffset = this._getFrameOffset(i);\r\n            var offset = frameOffset.add(pOffset);\r\n            var frame = new TexturePackerFrame(i, scale, offset);\r\n            this.frames.push(frame);\r\n            //Update Output UVs\r\n            if (update) {\r\n                this._updateMeshUV(m, i);\r\n                this._updateTextureReferences(m);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n    * Calculates the frames Offset.\r\n    * @param index of the frame\r\n    * @returns Vector2\r\n    */\r\n    TexturePacker.prototype._getFrameOffset = function (index) {\r\n        var meshLength = this.meshes.length;\r\n        var uvStep, yStep, xStep;\r\n        switch (this.options.layout) {\r\n            case 0:\r\n                //STRIP_LAYOUT\r\n                uvStep = 1 / meshLength;\r\n                return new Vector2(index * uvStep, 0);\r\n                break;\r\n            case 1:\r\n                //POWER2\r\n                var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                yStep = Math.floor(index / sqrtCount);\r\n                xStep = index - (yStep * sqrtCount);\r\n                uvStep = 1 / sqrtCount;\r\n                return new Vector2(xStep * uvStep, yStep * uvStep);\r\n                break;\r\n            case 2:\r\n                //COLNUM\r\n                var cols = this.options.colnum || 1;\r\n                var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                xStep = Math.floor(index / rowCnt);\r\n                yStep = index - (xStep * rowCnt);\r\n                uvStep = new Vector2(1 / cols, 1 / rowCnt);\r\n                return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\r\n                break;\r\n        }\r\n        return Vector2.Zero();\r\n    };\r\n    /**\r\n    * Updates a Mesh to the frame data\r\n    * @param mesh that is the target\r\n    * @param frameID or the frame index\r\n    */\r\n    TexturePacker.prototype._updateMeshUV = function (mesh, frameID) {\r\n        var frame = this.frames[frameID];\r\n        var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\r\n        var uvOut = [];\r\n        var toCount = 0;\r\n        if (uvIn.length) {\r\n            toCount = uvIn.length || 0;\r\n        }\r\n        for (var i = 0; i < toCount; i += 2) {\r\n            uvOut.push((uvIn[i] * frame.scale.x) + frame.offset.x, (uvIn[i + 1] * frame.scale.y) + frame.offset.y);\r\n        }\r\n        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\r\n    };\r\n    /**\r\n    * Updates a Meshes materials to use the texture packer channels\r\n    * @param m is the mesh to target\r\n    * @param force all channels on the packer to be set.\r\n    */\r\n    TexturePacker.prototype._updateTextureReferences = function (m, force) {\r\n        if (force === void 0) { force = false; }\r\n        var mat = m.material;\r\n        var sKeys = Object.keys(this.sets);\r\n        var _dispose = function (_t) {\r\n            if ((_t.dispose)) {\r\n                _t.dispose();\r\n            }\r\n        };\r\n        for (var i = 0; i < sKeys.length; i++) {\r\n            var setName = sKeys[i];\r\n            if (!force) {\r\n                if (!mat) {\r\n                    return;\r\n                }\r\n                if (mat[setName] !== null) {\r\n                    _dispose(mat[setName]);\r\n                    mat[setName] = this.sets[setName];\r\n                }\r\n            }\r\n            else {\r\n                if (mat[setName] !== null) {\r\n                    _dispose(mat[setName]);\r\n                }\r\n                mat[setName] = this.sets[setName];\r\n            }\r\n        }\r\n    };\r\n    /**\r\n    * Public method to set a Mesh to a frame\r\n    * @param m that is the target\r\n    * @param frameID or the frame index\r\n    * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n    */\r\n    TexturePacker.prototype.setMeshToFrame = function (m, frameID, updateMaterial) {\r\n        if (updateMaterial === void 0) { updateMaterial = false; }\r\n        this._updateMeshUV(m, frameID);\r\n        if (updateMaterial) {\r\n            this._updateTextureReferences(m, true);\r\n        }\r\n    };\r\n    /**\r\n    * Starts the async promise to compile the texture packer.\r\n    * @returns Promise<void>\r\n    */\r\n    TexturePacker.prototype.processAsync = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            try {\r\n                if (_this.meshes.length === 0) {\r\n                    //Must be a JSON load!\r\n                    resolve();\r\n                    return;\r\n                }\r\n                var done_1 = 0;\r\n                var doneCheck_1 = function (mat) {\r\n                    done_1++;\r\n                    //Check Status of all Textures on all meshes, till they are ready.\r\n                    if (_this.options.map) {\r\n                        for (var j = 0; j < _this.options.map.length; j++) {\r\n                            var index = _this.options.map[j];\r\n                            var t = mat[index];\r\n                            if (t !== null) {\r\n                                if (!_this.sets[_this.options.map[j]]) {\r\n                                    _this.sets[_this.options.map[j]] = true;\r\n                                }\r\n                                _this._expecting++;\r\n                            }\r\n                        }\r\n                        if (done_1 === _this.meshes.length) {\r\n                            _this._createFrames(resolve);\r\n                        }\r\n                    }\r\n                };\r\n                var _loop_2 = function (i) {\r\n                    var mesh = _this.meshes[i];\r\n                    var material = mesh.material;\r\n                    if (!material) {\r\n                        done_1++;\r\n                        if (done_1 === _this.meshes.length) {\r\n                            return { value: _this._createFrames(resolve) };\r\n                        }\r\n                        return \"continue\";\r\n                    }\r\n                    material.forceCompilationAsync(mesh).then(function () {\r\n                        doneCheck_1(material);\r\n                    });\r\n                };\r\n                for (var i = 0; i < _this.meshes.length; i++) {\r\n                    var state_1 = _loop_2(i);\r\n                    if (typeof state_1 === \"object\")\r\n                        return state_1.value;\r\n                }\r\n            }\r\n            catch (e) {\r\n                return reject(e);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n    * Disposes all textures associated with this packer\r\n    */\r\n    TexturePacker.prototype.dispose = function () {\r\n        var sKeys = Object.keys(this.sets);\r\n        for (var i = 0; i < sKeys.length; i++) {\r\n            var channel = sKeys[i];\r\n            this.sets[channel].dispose();\r\n        }\r\n    };\r\n    /**\r\n    * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n    * @param imageType is the image type to use.\r\n    * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n    */\r\n    TexturePacker.prototype.download = function (imageType, quality) {\r\n        var _this = this;\r\n        if (imageType === void 0) { imageType = 'png'; }\r\n        if (quality === void 0) { quality = 1; }\r\n        setTimeout(function () {\r\n            var pack = {\r\n                name: _this.name,\r\n                sets: {},\r\n                options: {},\r\n                frames: []\r\n            };\r\n            var sKeys = Object.keys(_this.sets);\r\n            var oKeys = Object.keys(_this.options);\r\n            try {\r\n                for (var i = 0; i < sKeys.length; i++) {\r\n                    var channel = sKeys[i];\r\n                    var dt = _this.sets[channel];\r\n                    pack.sets[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);\r\n                }\r\n                for (var i = 0; i < oKeys.length; i++) {\r\n                    var opt = oKeys[i];\r\n                    pack.options[opt] = _this.options[opt];\r\n                }\r\n                for (var i = 0; i < _this.frames.length; i++) {\r\n                    var _f = _this.frames[i];\r\n                    pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\r\n                }\r\n            }\r\n            catch (err) {\r\n                Logger.Warn(\"Unable to download: \" + err);\r\n                return;\r\n            }\r\n            var data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\r\n            var _a = document.createElement('a');\r\n            _a.setAttribute(\"href\", data);\r\n            _a.setAttribute(\"download\", _this.name + \"_texurePackage.json\");\r\n            document.body.appendChild(_a);\r\n            _a.click();\r\n            _a.remove();\r\n        }, 0);\r\n    };\r\n    /**\r\n    * Public method to load a texturePacker JSON file.\r\n    * @param data of the JSON file in string format.\r\n    */\r\n    TexturePacker.prototype.updateFromJSON = function (data) {\r\n        try {\r\n            var parsedData = JSON.parse(data);\r\n            this.name = parsedData.name;\r\n            var _options = Object.keys(parsedData.options);\r\n            for (var i = 0; i < _options.length; i++) {\r\n                this.options[_options[i]] = parsedData.options[_options[i]];\r\n            }\r\n            for (var i = 0; i < parsedData.frames.length; i += 4) {\r\n                var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\r\n                this.frames.push(frame);\r\n            }\r\n            var channels = Object.keys(parsedData.sets);\r\n            for (var i = 0; i < channels.length; i++) {\r\n                var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\r\n                this.sets[channels[i]] = _t;\r\n            }\r\n        }\r\n        catch (err) {\r\n            Logger.Warn(\"Unable to update from JSON: \" + err);\r\n        }\r\n    };\r\n    /** Packer Layout Constant 0 */\r\n    TexturePacker.LAYOUT_STRIP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    TexturePacker.LAYOUT_POWER2 = 1;\r\n    /** Packer Layout Constant 2 */\r\n    TexturePacker.LAYOUT_COLNUM = 2;\r\n    /** Packer Layout Constant 0 */\r\n    TexturePacker.SUBUV_WRAP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    TexturePacker.SUBUV_EXTEND = 1;\r\n    /** Packer Layout Constant 2 */\r\n    TexturePacker.SUBUV_COLOR = 2;\r\n    return TexturePacker;\r\n}());\r\nexport { TexturePacker };\r\n"]},"metadata":{},"sourceType":"module"}