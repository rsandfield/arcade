{"ast":null,"code":"import { Animation } from \"./animation\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Observable } from \"../Misc/observable\";\nimport { Scene } from \"../scene\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\nimport { PrecisionDate } from '../Misc/precisionDate';\nimport { Bone } from '../Bones/bone';\n/**\r\n * Class used to store an actual running animation\r\n */\n\nvar Animatable =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Animatable\r\n   * @param scene defines the hosting scene\r\n   * @param target defines the target object\r\n   * @param fromFrame defines the starting frame number (default is 0)\r\n   * @param toFrame defines the ending frame number (default is 100)\r\n   * @param loopAnimation defines if the animation must loop (default is false)\r\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n   * @param animations defines a group of animation to add to the new Animatable\r\n   * @param onAnimationLoop defines a callback to call when animation loops\r\n   * @param isAdditive defines whether the animation should be evaluated additively\r\n   */\n  function Animatable(scene,\n  /** defines the target object */\n  target,\n  /** defines the starting frame number (default is 0) */\n  fromFrame,\n  /** defines the ending frame number (default is 100) */\n  toFrame,\n  /** defines if the animation must loop (default is false)  */\n  loopAnimation, speedRatio,\n  /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations,\n  /** defines a callback to call when animation loops */\n  onAnimationLoop,\n  /** defines whether the animation should be evaluated additively */\n  isAdditive) {\n    if (fromFrame === void 0) {\n      fromFrame = 0;\n    }\n\n    if (toFrame === void 0) {\n      toFrame = 100;\n    }\n\n    if (loopAnimation === void 0) {\n      loopAnimation = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1.0;\n    }\n\n    if (isAdditive === void 0) {\n      isAdditive = false;\n    }\n\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\n\n    this.disposeOnEnd = true;\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\n\n    this.animationStarted = false;\n    /**\r\n     * Observer raised when the animation ends\r\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\r\n     * Observer raised when the animation loops\r\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n\n    this._speedRatio = speedRatio;\n\n    scene._activeAnimatables.push(this);\n  }\n\n  Object.defineProperty(Animatable.prototype, \"syncRoot\", {\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\n    get: function () {\n      return this._syncRoot;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"masterFrame\", {\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\n    get: function () {\n      if (this._runtimeAnimations.length === 0) {\n        return 0;\n      }\n\n      return this._runtimeAnimations[0].currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"weight\", {\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\n    get: function () {\n      return this._weight;\n    },\n    set: function (value) {\n      if (value === -1) {\n        // -1 is ok and means no weight\n        this._weight = -1;\n        return;\n      } // Else weight must be in [0, 1] range\n\n\n      this._weight = Math.min(Math.max(value, 0), 1.0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"speedRatio\", {\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\n    get: function () {\n      return this._speedRatio;\n    },\n    set: function (value) {\n      for (var index = 0; index < this._runtimeAnimations.length; index++) {\n        var animation = this._runtimeAnimations[index];\n\n        animation._prepareForSpeedRatioChange(value);\n      }\n\n      this._speedRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\r\n   * Synchronize and normalize current Animatable with a source Animatable\r\n   * This is useful when using animation weights and when animations are not of the same length\r\n   * @param root defines the root Animatable to synchronize with\r\n   * @returns the current Animatable\r\n   */\n\n  Animatable.prototype.syncWith = function (root) {\n    this._syncRoot = root;\n\n    if (root) {\n      // Make sure this animatable will animate after the root\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Gets the list of runtime animations\r\n   * @returns an array of RuntimeAnimation\r\n   */\n\n\n  Animatable.prototype.getAnimations = function () {\n    return this._runtimeAnimations;\n  };\n  /**\r\n   * Adds more animations to the current animatable\r\n   * @param target defines the target of the animations\r\n   * @param animations defines the new animations to add\r\n   */\n\n\n  Animatable.prototype.appendAnimations = function (target, animations) {\n    var _this = this;\n\n    for (var index = 0; index < animations.length; index++) {\n      var animation = animations[index];\n      var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n\n      newRuntimeAnimation._onLoop = function () {\n        _this.onAnimationLoopObservable.notifyObservers(_this);\n\n        if (_this.onAnimationLoop) {\n          _this.onAnimationLoop();\n        }\n      };\n\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  };\n  /**\r\n   * Gets the source animation for a specific property\r\n   * @param property defines the propertyu to look for\r\n   * @returns null or the source animation for the given property\r\n   */\n\n\n  Animatable.prototype.getAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the runtime animation for a specific property\r\n   * @param property defines the propertyu to look for\r\n   * @returns null or the runtime animation for the given property\r\n   */\n\n\n  Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Resets the animatable to its original state\r\n   */\n\n\n  Animatable.prototype.reset = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  };\n  /**\r\n   * Allows the animatable to blend with current running animations\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   * @param blendingSpeed defines the blending speed to use\r\n   */\n\n\n  Animatable.prototype.enableBlending = function (blendingSpeed) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  };\n  /**\r\n   * Disable animation blending\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   */\n\n\n  Animatable.prototype.disableBlending = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  };\n  /**\r\n   * Jump directly to a given frame\r\n   * @param frame defines the frame to jump to\r\n   */\n\n\n  Animatable.prototype.goToFrame = function (frame) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    if (runtimeAnimations[0]) {\n      var fps = runtimeAnimations[0].animation.framePerSecond;\n      var currentFrame = runtimeAnimations[0].currentFrame;\n      var delay = this.speedRatio === 0 ? 0 : (frame - currentFrame) / fps * 1000 / this.speedRatio;\n\n      if (this._localDelayOffset === null) {\n        this._localDelayOffset = 0;\n      }\n\n      this._localDelayOffset -= delay;\n    }\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n  };\n  /**\r\n   * Pause the animation\r\n   */\n\n\n  Animatable.prototype.pause = function () {\n    if (this._paused) {\n      return;\n    }\n\n    this._paused = true;\n  };\n  /**\r\n   * Restart the animation\r\n   */\n\n\n  Animatable.prototype.restart = function () {\n    this._paused = false;\n  };\n\n  Animatable.prototype._raiseOnAnimationEnd = function () {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n\n    this.onAnimationEndObservable.notifyObservers(this);\n  };\n  /**\r\n   * Stop and delete the current animation\r\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n   */\n\n\n  Animatable.prototype.stop = function (animationName, targetMask) {\n    if (animationName || targetMask) {\n      var idx = this._scene._activeAnimatables.indexOf(this);\n\n      if (idx > -1) {\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\n          var runtimeAnimation = runtimeAnimations[index];\n\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n\n        if (runtimeAnimations.length == 0) {\n          this._scene._activeAnimatables.splice(idx, 1);\n\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n\n        this._raiseOnAnimationEnd();\n      }\n    }\n  };\n  /**\r\n   * Wait asynchronously for the animation to end\r\n   * @returns a promise which will be fullfilled when the animation ends\r\n   */\n\n\n  Animatable.prototype.waitAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.onAnimationEndObservable.add(function () {\n        resolve(_this);\n      }, undefined, undefined, _this, true);\n    });\n  };\n  /** @hidden */\n\n\n  Animatable.prototype._animate = function (delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n\n      return true;\n    }\n\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n\n    if (this._weight === 0) {\n      // We consider that an animation with a weight === 0 is \"actively\" paused\n      return true;\n    } // Animating\n\n\n    var running = false;\n    var runtimeAnimations = this._runtimeAnimations;\n    var index;\n\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      var animation = runtimeAnimations[index];\n      var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n\n    this.animationStarted = running;\n\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n\n        this._scene._activeAnimatables.splice(index, 1); // Dispose all runtime animations\n\n\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n\n      this._raiseOnAnimationEnd();\n\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n\n    return running;\n  };\n\n  return Animatable;\n}();\n\nexport { Animatable };\n\nScene.prototype._animate = function () {\n  if (!this.animationsEnabled) {\n    return;\n  } // Getting time\n\n\n  var now = PrecisionDate.Now;\n\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n\n    this._animationTimeLast = now;\n  }\n\n  this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  var animatables = this._activeAnimatables;\n\n  if (animatables.length === 0) {\n    return;\n  }\n\n  this._animationTime += this.deltaTime;\n  var animationTime = this._animationTime;\n\n  for (var index = 0; index < animatables.length; index++) {\n    var animatable = animatables[index];\n\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  } // Late animation bindings\n\n\n  this._processLateAnimationBindings();\n};\n\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\n  if (weight === void 0) {\n    weight = 1.0;\n  }\n\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\n\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n\n  var shouldRunTargetAnimations = targetMask ? targetMask(target) : true; // Local animations\n\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  } // Children animations\n\n\n  if (target.getAnimatables) {\n    var animatables = target.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n\n  animatable.reset();\n  return animatable;\n};\n\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n\n  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n    var child = children_1[_i];\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\n\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n\n  for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\n    var child = children_2[_i];\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n\n  return null;\n};\n\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  var result = [];\n\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n\n  return result;\n};\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\n\n\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  var animatables = this.getAllAnimatablesByTarget(target);\n\n  for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\n    var animatable = animatables_1[_i];\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\n\n\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (var i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop();\n    }\n\n    this._activeAnimatables = [];\n  }\n\n  for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\n    var group = _a[_i];\n    group.stop();\n  }\n};\n\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  var target = runtimeAnimation.target;\n\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\n\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n\n  var normalizer = 1.0;\n  var finalPosition = TmpVectors.Vector3[0];\n  var finalScaling = TmpVectors.Vector3[1];\n  var finalQuaternion = TmpVectors.Quaternion[0];\n  var startIndex = 0;\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var scale = 1;\n  var skipOverride = false;\n\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1; // We need to normalize the weights\n\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } // Add up the override animations\n\n\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n\n    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n\n      var scale = runtimeAnimation.weight / normalizer;\n      var currentPosition = TmpVectors.Vector3[2];\n      var currentScaling = TmpVectors.Vector3[3];\n      var currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex_1];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    var currentPosition = TmpVectors.Vector3[2];\n    var currentScaling = TmpVectors.Vector3[3];\n    var currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n\n  var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\n\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var cumulativeQuaternion = refQuaternion;\n\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    var normalizer = 1.0;\n    var quaternions = void 0;\n    var weights = void 0;\n\n    if (holder.totalWeight < 1.0) {\n      var scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n\n    for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    } // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n\n\n    var cumulativeAmount = 0;\n\n    for (var index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex_2];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n\n  return cumulativeQuaternion;\n};\n\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n\n  for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    var target = this._registeredForLateAnimationBindings.data[index];\n\n    for (var path in target._lateAnimationHolders) {\n      var holder = target._lateAnimationHolders[path];\n      var originalAnimation = holder.animations[0];\n      var originalValue = holder.originalValue;\n      var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n\n      var finalValue = target[path];\n\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        var quaternionMode = originalValue.w !== undefined;\n\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          var startIndex = 0;\n          var normalizer = 1.0;\n\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            var scale_1 = originalAnimation.weight / normalizer;\n\n            if (scale_1 !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale_1);\n              } else {\n                finalValue = originalAnimation.currentValue * scale_1;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n\n            startIndex = 1;\n          } // Add up the override animations\n\n\n          for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            var runtimeAnimation = holder.animations[animIndex];\n            var scale = runtimeAnimation.weight / normalizer;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          } // Add up the additive animations\n\n\n          for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {\n            var runtimeAnimation = holder.additiveAnimations[animIndex_3];\n            var scale = runtimeAnimation.weight;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n\n      target[path] = finalValue;\n    }\n\n    target._lateAnimationHolders = {};\n  }\n\n  this._registeredForLateAnimationBindings.reset();\n};\n\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\n  if (rescaleAsRequired === void 0) {\n    rescaleAsRequired = false;\n  }\n\n  if (skelDimensionsRatio === void 0) {\n    skelDimensionsRatio = null;\n  } // all animation may be coming from a library skeleton, so may need to create animation\n\n\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  } // get animation info / verify there is such a range from the source bone\n\n\n  var sourceRange = source.animations[0].getRange(rangeName);\n\n  if (!sourceRange) {\n    return false;\n  }\n\n  var from = sourceRange.from;\n  var to = sourceRange.to;\n  var sourceKeys = source.animations[0].getKeys(); // rescaling prep\n\n  var sourceBoneLength = source.length;\n  var sourceParent = source.getParent();\n  var parent = this.getParent();\n  var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  var destKeys = this.animations[0].getKeys(); // loop vars declaration\n\n  var orig;\n  var origTranslation;\n  var mat;\n\n  for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone(); // scale based on parent ratio, when bone has parent\n\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio)); // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio)); // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};","map":{"version":3,"sources":["C:/Users/rober/Documents/Computer Science/Side Projects/arcade/node_modules/@babylonjs/core/Animations/animatable.js"],"names":["Animation","RuntimeAnimation","Observable","Scene","Matrix","Quaternion","Vector3","TmpVectors","PrecisionDate","Bone","Animatable","scene","target","fromFrame","toFrame","loopAnimation","speedRatio","onAnimationEnd","animations","onAnimationLoop","isAdditive","_localDelayOffset","_pausedDelay","_runtimeAnimations","Array","_paused","_speedRatio","_weight","_syncRoot","disposeOnEnd","animationStarted","onAnimationEndObservable","onAnimationLoopObservable","_scene","appendAnimations","_activeAnimatables","push","Object","defineProperty","prototype","get","enumerable","configurable","length","currentFrame","set","value","Math","min","max","index","animation","_prepareForSpeedRatioChange","syncWith","root","indexOf","splice","getAnimations","_this","newRuntimeAnimation","_onLoop","notifyObservers","getAnimationByTargetProperty","property","runtimeAnimations","targetProperty","getRuntimeAnimationByTargetProperty","reset","enableBlending","blendingSpeed","disableBlending","goToFrame","frame","fps","framePerSecond","delay","pause","restart","_raiseOnAnimationEnd","stop","animationName","targetMask","idx","runtimeAnimation","name","dispose","waitAsync","Promise","resolve","reject","add","undefined","_animate","running","isRunning","animate","clear","animationsEnabled","now","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","_animationTime","animationTime","animatable","_processLateAnimationBindings","beginWeightedAnimation","from","to","weight","loop","returnedAnimatable","beginAnimation","stopCurrent","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","_i","children_1","child","beginDirectAnimation","beginDirectHierarchyAnimation","children_2","getAnimatableByTarget","getAllAnimatablesByTarget","animatables_1","stopAllAnimations","i","_a","animationGroups","group","_registerTargetForLateAnimationBinding","originalValue","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","targetPath","totalWeight","totalAdditiveWeight","additiveAnimations","_processLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","finalScaling","finalQuaternion","startIndex","originalAnimation","scale","skipOverride","decompose","currentValue","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","animIndex_1","multiplyToRef","LerpToRef","SlerpToRef","workValue","_animationState","clone","ComposeToRef","_processLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","copyFrom","quaternions","weights","cumulativeAmount","animIndex_2","data","path","matrixDecomposeMode","AllowMatrixDecomposeForInterpolation","m","finalValue","quaternionMode","w","Identity","scale_1","animIndex_3","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","ANIMATIONTYPE_MATRIX","setKeys","sourceRange","getRange","sourceKeys","getKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","key","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange"],"mappings":"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","sourcesContent":["import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\r\nimport { PrecisionDate } from '../Misc/precisionDate';\r\nimport { Bone } from '../Bones/bone';\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nvar Animatable = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     */\r\n    function Animatable(scene, \r\n    /** defines the target object */\r\n    target, \r\n    /** defines the starting frame number (default is 0) */\r\n    fromFrame, \r\n    /** defines the ending frame number (default is 100) */\r\n    toFrame, \r\n    /** defines if the animation must loop (default is false)  */\r\n    loopAnimation, speedRatio, \r\n    /** defines a callback to call when animation ends if it is not looping */\r\n    onAnimationEnd, animations, \r\n    /** defines a callback to call when animation loops */\r\n    onAnimationLoop, \r\n    /** defines whether the animation should be evaluated additively */\r\n    isAdditive) {\r\n        if (fromFrame === void 0) { fromFrame = 0; }\r\n        if (toFrame === void 0) { toFrame = 100; }\r\n        if (loopAnimation === void 0) { loopAnimation = false; }\r\n        if (speedRatio === void 0) { speedRatio = 1.0; }\r\n        if (isAdditive === void 0) { isAdditive = false; }\r\n        this.target = target;\r\n        this.fromFrame = fromFrame;\r\n        this.toFrame = toFrame;\r\n        this.loopAnimation = loopAnimation;\r\n        this.onAnimationEnd = onAnimationEnd;\r\n        this.onAnimationLoop = onAnimationLoop;\r\n        this.isAdditive = isAdditive;\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n        this._runtimeAnimations = new Array();\r\n        this._paused = false;\r\n        this._speedRatio = 1;\r\n        this._weight = -1.0;\r\n        this._syncRoot = null;\r\n        /**\r\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n         * This will only apply for non looping animation (default is true)\r\n         */\r\n        this.disposeOnEnd = true;\r\n        /**\r\n         * Gets a boolean indicating if the animation has started\r\n         */\r\n        this.animationStarted = false;\r\n        /**\r\n         * Observer raised when the animation ends\r\n         */\r\n        this.onAnimationEndObservable = new Observable();\r\n        /**\r\n         * Observer raised when the animation loops\r\n         */\r\n        this.onAnimationLoopObservable = new Observable();\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n    Object.defineProperty(Animatable.prototype, \"syncRoot\", {\r\n        /**\r\n         * Gets the root Animatable used to synchronize and normalize animations\r\n         */\r\n        get: function () {\r\n            return this._syncRoot;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"masterFrame\", {\r\n        /**\r\n         * Gets the current frame of the first RuntimeAnimation\r\n         * Used to synchronize Animatables\r\n         */\r\n        get: function () {\r\n            if (this._runtimeAnimations.length === 0) {\r\n                return 0;\r\n            }\r\n            return this._runtimeAnimations[0].currentFrame;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"weight\", {\r\n        /**\r\n         * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n         */\r\n        get: function () {\r\n            return this._weight;\r\n        },\r\n        set: function (value) {\r\n            if (value === -1) { // -1 is ok and means no weight\r\n                this._weight = -1;\r\n                return;\r\n            }\r\n            // Else weight must be in [0, 1] range\r\n            this._weight = Math.min(Math.max(value, 0), 1.0);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"speedRatio\", {\r\n        /**\r\n         * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n         */\r\n        get: function () {\r\n            return this._speedRatio;\r\n        },\r\n        set: function (value) {\r\n            for (var index = 0; index < this._runtimeAnimations.length; index++) {\r\n                var animation = this._runtimeAnimations[index];\r\n                animation._prepareForSpeedRatioChange(value);\r\n            }\r\n            this._speedRatio = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with\r\n     * @returns the current Animatable\r\n     */\r\n    Animatable.prototype.syncWith = function (root) {\r\n        this._syncRoot = root;\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    Animatable.prototype.getAnimations = function () {\r\n        return this._runtimeAnimations;\r\n    };\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    Animatable.prototype.appendAnimations = function (target, animations) {\r\n        var _this = this;\r\n        for (var index = 0; index < animations.length; index++) {\r\n            var animation = animations[index];\r\n            var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = function () {\r\n                _this.onAnimationLoopObservable.notifyObservers(_this);\r\n                if (_this.onAnimationLoop) {\r\n                    _this.onAnimationLoop();\r\n                }\r\n            };\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    Animatable.prototype.getAnimationByTargetProperty = function (property) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    Animatable.prototype.reset = function () {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    };\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    Animatable.prototype.enableBlending = function (blendingSpeed) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    };\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    Animatable.prototype.disableBlending = function () {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    };\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    Animatable.prototype.goToFrame = function (frame) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        if (runtimeAnimations[0]) {\r\n            var fps = runtimeAnimations[0].animation.framePerSecond;\r\n            var currentFrame = runtimeAnimations[0].currentFrame;\r\n            var delay = this.speedRatio === 0 ? 0 : ((frame - currentFrame) / fps * 1000) / this.speedRatio;\r\n            if (this._localDelayOffset === null) {\r\n                this._localDelayOffset = 0;\r\n            }\r\n            this._localDelayOffset -= delay;\r\n        }\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n    };\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    Animatable.prototype.pause = function () {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    };\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    Animatable.prototype.restart = function () {\r\n        this._paused = false;\r\n    };\r\n    Animatable.prototype._raiseOnAnimationEnd = function () {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    };\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    Animatable.prototype.stop = function (animationName, targetMask) {\r\n        if (animationName || targetMask) {\r\n            var idx = this._scene._activeAnimatables.indexOf(this);\r\n            if (idx > -1) {\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n                for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    var runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n                if (runtimeAnimations.length == 0) {\r\n                    this._scene._activeAnimatables.splice(idx, 1);\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n                for (var index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fullfilled when the animation ends\r\n     */\r\n    Animatable.prototype.waitAsync = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.onAnimationEndObservable.add(function () {\r\n                resolve(_this);\r\n            }, undefined, undefined, _this, true);\r\n        });\r\n    };\r\n    /** @hidden */\r\n    Animatable.prototype._animate = function (delay) {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        }\r\n        else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n        if (this._weight === 0) { // We consider that an animation with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n        // Animating\r\n        var running = false;\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        var index;\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            var animation = runtimeAnimations[index];\r\n            var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n        this.animationStarted = running;\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n            this._raiseOnAnimationEnd();\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n        return running;\r\n    };\r\n    return Animatable;\r\n}());\r\nexport { Animatable };\r\nScene.prototype._animate = function () {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n    // Getting time\r\n    var now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n    var animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n    this._animationTime += this.deltaTime;\r\n    var animationTime = this._animationTime;\r\n    for (var index = 0; index < animatables.length; index++) {\r\n        var animatable = animatables[index];\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\r\n    if (weight === void 0) { weight = 1.0; }\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n    return returnedAnimatable;\r\n};\r\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (stopCurrent === void 0) { stopCurrent = true; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n    var shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        var animatables = target.getAnimatables();\r\n        for (var index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n    animatable.reset();\r\n    return animatable;\r\n};\r\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (stopCurrent === void 0) { stopCurrent = true; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var children = target.getDescendants(directDescendantsOnly);\r\n    var result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n        var child = children_1[_i];\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n    return result;\r\n};\r\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n    var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n    return animatable;\r\n};\r\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var children = target.getDescendants(directDescendantsOnly);\r\n    var result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\r\n        var child = children_2[_i];\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n    return result;\r\n};\r\nScene.prototype.getAnimatableByTarget = function (target) {\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n    return null;\r\n};\r\nScene.prototype.getAllAnimatablesByTarget = function (target) {\r\n    var result = [];\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\r\n    var animatables = this.getAllAnimatablesByTarget(target);\r\n    for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\r\n        var animatable = animatables_1[_i];\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function () {\r\n    if (this._activeAnimatables) {\r\n        for (var i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop();\r\n        }\r\n        this._activeAnimatables = [];\r\n    }\r\n    for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\r\n        var group = _a[_i];\r\n        group.stop();\r\n    }\r\n};\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\r\n    var target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue\r\n        };\r\n    }\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    }\r\n    else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n    var normalizer = 1.0;\r\n    var finalPosition = TmpVectors.Vector3[0];\r\n    var finalScaling = TmpVectors.Vector3[1];\r\n    var finalQuaternion = TmpVectors.Quaternion[0];\r\n    var startIndex = 0;\r\n    var originalAnimation = holder.animations[0];\r\n    var originalValue = holder.originalValue;\r\n    var scale = 1;\r\n    var skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n    else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            }\r\n            else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n        for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n            var scale = runtimeAnimation.weight / normalizer;\r\n            var currentPosition = TmpVectors.Vector3[2];\r\n            var currentScaling = TmpVectors.Vector3[3];\r\n            var currentQuaternion = TmpVectors.Quaternion[1];\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n    }\r\n    // Add up the additive animations\r\n    for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex_1];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n        var currentPosition = TmpVectors.Vector3[2];\r\n        var currentScaling = TmpVectors.Vector3[3];\r\n        var currentQuaternion = TmpVectors.Quaternion[1];\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n    var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n    var originalAnimation = holder.animations[0];\r\n    var originalValue = holder.originalValue;\r\n    var cumulativeQuaternion = refQuaternion;\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    }\r\n    else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    }\r\n    else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        var normalizer = 1.0;\r\n        var quaternions = void 0;\r\n        var weights = void 0;\r\n        if (holder.totalWeight < 1.0) {\r\n            var scale = 1.0 - holder.totalWeight;\r\n            quaternions = [];\r\n            weights = [];\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        }\r\n        else {\r\n            if (holder.animations.length === 2) { // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n        for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n        var cumulativeAmount = 0;\r\n        for (var index = 0; index < quaternions.length;) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n    // Add up the additive animations\r\n    for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex_2];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n    return cumulativeQuaternion;\r\n};\r\nScene.prototype._processLateAnimationBindings = function () {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        var target = this._registeredForLateAnimationBindings.data[index];\r\n        for (var path in target._lateAnimationHolders) {\r\n            var holder = target._lateAnimationHolders[path];\r\n            var originalAnimation = holder.animations[0];\r\n            var originalValue = holder.originalValue;\r\n            var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n            var finalValue = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            }\r\n            else {\r\n                var quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                }\r\n                else {\r\n                    var startIndex = 0;\r\n                    var normalizer = 1.0;\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        }\r\n                        else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        }\r\n                        else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        }\r\n                        else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    }\r\n                    else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        var scale_1 = originalAnimation.weight / normalizer;\r\n                        if (scale_1 !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale_1);\r\n                            }\r\n                            else {\r\n                                finalValue = originalAnimation.currentValue * scale_1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n                        startIndex = 1;\r\n                    }\r\n                    // Add up the override animations\r\n                    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        var runtimeAnimation = holder.animations[animIndex];\r\n                        var scale = runtimeAnimation.weight / normalizer;\r\n                        if (!scale) {\r\n                            continue;\r\n                        }\r\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        }\r\n                        else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                    // Add up the additive animations\r\n                    for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {\r\n                        var runtimeAnimation = holder.additiveAnimations[animIndex_3];\r\n                        var scale = runtimeAnimation.weight;\r\n                        if (!scale) {\r\n                            continue;\r\n                        }\r\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        }\r\n                        else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\r\n    if (rescaleAsRequired === void 0) { rescaleAsRequired = false; }\r\n    if (skelDimensionsRatio === void 0) { skelDimensionsRatio = null; }\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n    // get animation info / verify there is such a range from the source bone\r\n    var sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    var from = sourceRange.from;\r\n    var to = sourceRange.to;\r\n    var sourceKeys = source.animations[0].getKeys();\r\n    // rescaling prep\r\n    var sourceBoneLength = source.length;\r\n    var sourceParent = source.getParent();\r\n    var parent = this.getParent();\r\n    var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n    var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n    var destKeys = this.animations[0].getKeys();\r\n    // loop vars declaration\r\n    var orig;\r\n    var origTranslation;\r\n    var mat;\r\n    for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                }\r\n                else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                }\r\n                else {\r\n                    mat = orig.value;\r\n                }\r\n            }\r\n            else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}