{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { FilesInputStore } from \"../Misc/filesInputStore\";\nimport { Scene } from \"../scene\";\nimport { Engine } from \"../Engines/engine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\n\nexport var SceneLoaderAnimationGroupLoadingMode;\n\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\r\n   * Reset all old animations to initial state then dispose them.\r\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\r\n   * Stop all old animations.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\r\n   * Restart old animations from first frame.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\r\n   * Old animations remains untouched.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\n\n\nvar SceneLoader =\n/** @class */\nfunction () {\n  function SceneLoader() {}\n\n  Object.defineProperty(SceneLoader, \"ForceFullSceneLoadingForIncremental\", {\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\n    get: function () {\n      return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n    },\n    set: function (value) {\n      SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"ShowLoadingScreen\", {\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\n    get: function () {\n      return SceneLoaderFlags.ShowLoadingScreen;\n    },\n    set: function (value) {\n      SceneLoaderFlags.ShowLoadingScreen = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"loggingLevel\", {\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\n    get: function () {\n      return SceneLoaderFlags.loggingLevel;\n    },\n    set: function (value) {\n      SceneLoaderFlags.loggingLevel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"CleanBoneMatrixWeights\", {\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\n    get: function () {\n      return SceneLoaderFlags.CleanBoneMatrixWeights;\n    },\n    set: function (value) {\n      SceneLoaderFlags.CleanBoneMatrixWeights = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the default plugin (used to load Babylon files)\r\n   * @returns the .babylon plugin\r\n   */\n\n  SceneLoader.GetDefaultPlugin = function () {\n    return SceneLoader._registeredPlugins[\".babylon\"];\n  };\n\n  SceneLoader._GetPluginForExtension = function (extension) {\n    var registeredPlugin = SceneLoader._registeredPlugins[extension];\n\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\");\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForDirectLoad = function (data) {\n    for (var extension in SceneLoader._registeredPlugins) {\n      var plugin = SceneLoader._registeredPlugins[extension].plugin;\n\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._registeredPlugins[extension];\n      }\n    }\n\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForFilename = function (sceneFilename) {\n    var queryStringPosition = sceneFilename.indexOf(\"?\");\n\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n\n    var dotPosition = sceneFilename.lastIndexOf(\".\");\n    var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  };\n\n  SceneLoader._GetDirectLoad = function (sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n\n    return null;\n  };\n\n  SceneLoader._LoadData = function (fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\n    var directLoad = SceneLoader._GetDirectLoad(fileInfo.name);\n\n    var registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.name) : SceneLoader._GetPluginForFilename(fileInfo.name);\n    var plugin;\n\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n\n    if (!plugin) {\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n\n    if (directLoad) {\n      if (plugin.directLoad) {\n        var result = plugin.directLoad(scene, directLoad);\n\n        if (result.then) {\n          result.then(function (data) {\n            onSuccess(plugin, data);\n          }).catch(function (error) {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n\n      return plugin;\n    }\n\n    var useArrayBuffer = registeredPlugin.isBinary;\n\n    var dataCallback = function (data, responseURL) {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n\n      onSuccess(plugin, data, responseURL);\n    };\n\n    var request = null;\n    var pluginDisposed = false;\n    var onDisposeObservable = plugin.onDisposeObservable;\n\n    if (onDisposeObservable) {\n      onDisposeObservable.add(function () {\n        pluginDisposed = true;\n\n        if (request) {\n          request.abort();\n          request = null;\n        }\n\n        onDispose();\n      });\n    }\n\n    var manifestChecked = function () {\n      if (pluginDisposed) {\n        return;\n      }\n\n      var successCallback = function (data, request) {\n        dataCallback(data, request ? request.responseURL : undefined);\n      };\n\n      var errorCallback = function (error) {\n        onError(error.message, error);\n      };\n\n      request = plugin.requestFile ? plugin.requestFile(scene, fileInfo.url, successCallback, onProgress, useArrayBuffer, errorCallback) : scene._requestFile(fileInfo.url, successCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n\n    var file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];\n\n    if (fileInfo.rootUrl.indexOf(\"file:\") === -1 || fileInfo.rootUrl.indexOf(\"file:\") !== -1 && !file) {\n      var engine = scene.getEngine();\n      var canUseOfflineSupport = engine.enableOfflineSupport;\n\n      if (canUseOfflineSupport) {\n        // Also check for exceptions\n        var exceptionFound = false;\n\n        for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {\n          var regex = _a[_i];\n\n          if (regex.test(fileInfo.url)) {\n            exceptionFound = true;\n            break;\n          }\n        }\n\n        canUseOfflineSupport = !exceptionFound;\n      }\n\n      if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n        // Checking if a manifest file has been set for this scene and if offline mode has been requested\n        scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n      } else {\n        manifestChecked();\n      }\n    } // Loading file from disk via input file or drag'n'drop\n    else {\n      if (file) {\n        var errorCallback = function (error) {\n          onError(error.message, error);\n        };\n\n        request = plugin.readFile ? plugin.readFile(scene, file, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._readFile(file, dataCallback, onProgress, useArrayBuffer, errorCallback);\n      } else {\n        onError(\"Unable to find file named \" + fileInfo.name);\n      }\n    }\n\n    return plugin;\n  };\n\n  SceneLoader._GetFileInfo = function (rootUrl, sceneFilename) {\n    var url;\n    var name;\n    var file = null;\n\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      var sceneFile = sceneFilename;\n      url = rootUrl + sceneFile.name;\n      name = sceneFile.name;\n      file = sceneFile;\n    } else {\n      var filename = sceneFilename;\n\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n\n      url = rootUrl + filename;\n      name = filename;\n    }\n\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file\n    };\n  }; // Public functions\n\n  /**\r\n   * Gets a plugin that can load the given extension\r\n   * @param extension defines the extension to load\r\n   * @returns a plugin or null if none works\r\n   */\n\n\n  SceneLoader.GetPluginForExtension = function (extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  };\n  /**\r\n   * Gets a boolean indicating that the given extension can be loaded\r\n   * @param extension defines the extension to load\r\n   * @returns true if the extension is supported\r\n   */\n\n\n  SceneLoader.IsPluginForExtensionAvailable = function (extension) {\n    return !!SceneLoader._registeredPlugins[extension];\n  };\n  /**\r\n   * Adds a new plugin to the list of registered plugins\r\n   * @param plugin defines the plugin to add\r\n   */\n\n\n  SceneLoader.RegisterPlugin = function (plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      var extension = plugin.extensions;\n      SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      var extensions = plugin.extensions;\n      Object.keys(extensions).forEach(function (extension) {\n        SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions[extension].isBinary\n        };\n      });\n    }\n  };\n  /**\r\n   * Import meshes into a scene\r\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene the instance of BABYLON.Scene to append to\r\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.ImportMesh = function (meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function () {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function (message, exception) {\n      var errorMessage = \"Unable to import meshes from \" + fileInfo.url + \": \" + message;\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n\n    var successHandler = function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n      scene.importedMeshesFiles.push(fileInfo.url);\n\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data, responseURL) {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n\n      if (plugin.importMesh) {\n        var syncedPlugin = plugin;\n        var meshes = new Array();\n        var particleSystems = new Array();\n        var skeletons = new Array();\n\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (result) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Import meshes into a scene\r\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene the instance of BABYLON.Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n   */\n\n\n  SceneLoader.ImportMeshAsync = function (meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights\n        });\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Load a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.Load = function (rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\n  };\n  /**\r\n   * Load a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded scene\r\n   */\n\n\n  SceneLoader.LoadAsync = function (rootUrl, sceneFilename, engine, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Append a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.Append = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    var _this = this;\n\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    if (SceneLoader.ShowLoadingScreen && !this._showingLoadingScreen) {\n      this._showingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(function () {\n        scene.getEngine().hideLoadingUI();\n        _this._showingLoadingScreen = false;\n      });\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function () {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function (message, exception) {\n      var errorMessage = \"Unable to load from \" + fileInfo.url + (message ? \": \" + message : \"\");\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function () {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.load) {\n        var syncedPlugin = plugin;\n\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function () {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Append a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The given scene\r\n   */\n\n\n  SceneLoader.AppendAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Load a scene into an asset container\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.LoadAssetContainer = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function () {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function (message, exception) {\n      var errorMessage = \"Unable to load assets from \" + fileInfo.url + (message ? \": \" + message : \"\");\n\n      if (exception && exception.message) {\n        errorMessage += \" (\" + exception.message + \")\";\n      }\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function (assets) {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.loadAssetContainer) {\n        var syncedPlugin = plugin;\n        var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n\n        if (!assetContainer) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (assetContainer) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Load a scene into an asset container\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n   * @param scene is the instance of Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded asset container\r\n   */\n\n\n  SceneLoader.LoadAssetContainerAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, function (assetContainer) {\n        resolve(assetContainer);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Import animations from a file into a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   */\n\n\n  SceneLoader.ImportAnimations = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {\n        var animatable = _a[_i];\n        animatable.reset();\n      }\n\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(function (animationGroup) {\n        animationGroup.dispose();\n      });\n      var nodes = scene.getNodes();\n      nodes.forEach(function (node) {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(function (animationGroup) {\n            animationGroup.dispose();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.stop();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n\n    var startingIndexForNewAnimatables = scene.animatables.length;\n\n    var onAssetContainerLoaded = function (container) {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  };\n  /**\r\n   * Import animations from a file into a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns the updated scene with imported animations\r\n   */\n\n\n  SceneLoader.ImportAnimationsAsync = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function (_scene) {\n        resolve(_scene);\n      }, onProgress, function (_scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * No logging while loading\r\n   */\n\n\n  SceneLoader.NO_LOGGING = 0;\n  /**\r\n   * Minimal logging while loading\r\n   */\n\n  SceneLoader.MINIMAL_LOGGING = 1;\n  /**\r\n   * Summary logging while loading\r\n   */\n\n  SceneLoader.SUMMARY_LOGGING = 2;\n  /**\r\n   * Detailled logging while loading\r\n   */\n\n  SceneLoader.DETAILED_LOGGING = 3; // Members\n\n  /**\r\n   * Event raised when a plugin is used to load a scene\r\n   */\n\n  SceneLoader.OnPluginActivatedObservable = new Observable();\n  SceneLoader._registeredPlugins = {};\n  SceneLoader._showingLoadingScreen = false;\n  return SceneLoader;\n}();\n\nexport { SceneLoader };","map":{"version":3,"sources":["C:/Users/rober/Documents/Computer Science/Side Projects/arcade/node_modules/@babylonjs/core/Loading/sceneLoader.js"],"names":["Tools","Observable","FilesInputStore","Scene","Engine","EngineStore","Logger","SceneLoaderFlags","SceneLoaderAnimationGroupLoadingMode","SceneLoader","Object","defineProperty","get","ForceFullSceneLoadingForIncremental","set","value","enumerable","configurable","ShowLoadingScreen","loggingLevel","CleanBoneMatrixWeights","GetDefaultPlugin","_registeredPlugins","_GetPluginForExtension","extension","registeredPlugin","Warn","_GetPluginForDirectLoad","data","plugin","canDirectLoad","_GetPluginForFilename","sceneFilename","queryStringPosition","indexOf","substring","dotPosition","lastIndexOf","length","toLowerCase","_GetDirectLoad","substr","_LoadData","fileInfo","scene","onSuccess","onProgress","onError","onDispose","pluginExtension","directLoad","name","createPlugin","undefined","OnPluginActivatedObservable","notifyObservers","result","then","catch","error","useArrayBuffer","isBinary","dataCallback","responseURL","isDisposed","request","pluginDisposed","onDisposeObservable","add","abort","manifestChecked","successCallback","errorCallback","message","requestFile","url","_requestFile","file","FilesToLoad","rootUrl","engine","getEngine","canUseOfflineSupport","enableOfflineSupport","exceptionFound","_i","_a","disableOfflineSupportExceptionRules","regex","test","OfflineProviderFactory","offlineProvider","disableManifestCheck","readFile","_readFile","_GetFileInfo","GetFilename","GetFolderPath","sceneFile","filename","Error","GetPluginForExtension","IsPluginForExtensionAvailable","RegisterPlugin","extensions","keys","forEach","ImportMesh","meshNames","LastCreatedScene","loadingToken","_addPendingData","disposeHandler","_removePendingData","errorHandler","exception","errorMessage","progressHandler","event","e","successHandler","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","importedMeshesFiles","push","rewriteRootURL","importMesh","syncedPlugin","Array","loadingPluginName","asyncedPlugin","importMeshAsync","ImportMeshAsync","Promise","resolve","reject","Load","LastCreatedEngine","Append","LoadAsync","_this","_showingLoadingScreen","displayLoadingUI","executeWhenReady","hideLoadingUI","load","loadAsync","AppendAsync","LoadAssetContainer","assets","loadAssetContainer","assetContainer","loadAssetContainerAsync","LoadAssetContainerAsync","ImportAnimations","overwriteAnimations","animationGroupLoadingMode","targetConverter","Clean","animatables","animatable","reset","stopAllAnimations","slice","animationGroup","dispose","nodes","getNodes","node","animations","Stop","stop","Sync","restart","NoSync","startingIndexForNewAnimatables","onAssetContainerLoaded","container","mergeAnimationsTo","onAnimationFileImportedObservable","ImportAnimationsAsync","_scene","NO_LOGGING","MINIMAL_LOGGING","SUMMARY_LOGGING","DETAILED_LOGGING"],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { FilesInputStore } from \"../Misc/filesInputStore\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport var SceneLoaderAnimationGroupLoadingMode;\r\n(function (SceneLoaderAnimationGroupLoadingMode) {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\r\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\r\nvar SceneLoader = /** @class */ (function () {\r\n    function SceneLoader() {\r\n    }\r\n    Object.defineProperty(SceneLoader, \"ForceFullSceneLoadingForIncremental\", {\r\n        /**\r\n         * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneLoader, \"ShowLoadingScreen\", {\r\n        /**\r\n         * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags.ShowLoadingScreen;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags.ShowLoadingScreen = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneLoader, \"loggingLevel\", {\r\n        /**\r\n         * Defines the current logging level (while loading the scene)\r\n         * @ignorenaming\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags.loggingLevel;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags.loggingLevel = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneLoader, \"CleanBoneMatrixWeights\", {\r\n        /**\r\n         * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    SceneLoader.GetDefaultPlugin = function () {\r\n        return SceneLoader._registeredPlugins[\".babylon\"];\r\n    };\r\n    SceneLoader._GetPluginForExtension = function (extension) {\r\n        var registeredPlugin = SceneLoader._registeredPlugins[extension];\r\n        if (registeredPlugin) {\r\n            return registeredPlugin;\r\n        }\r\n        Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\");\r\n        return SceneLoader.GetDefaultPlugin();\r\n    };\r\n    SceneLoader._GetPluginForDirectLoad = function (data) {\r\n        for (var extension in SceneLoader._registeredPlugins) {\r\n            var plugin = SceneLoader._registeredPlugins[extension].plugin;\r\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n                return SceneLoader._registeredPlugins[extension];\r\n            }\r\n        }\r\n        return SceneLoader.GetDefaultPlugin();\r\n    };\r\n    SceneLoader._GetPluginForFilename = function (sceneFilename) {\r\n        var queryStringPosition = sceneFilename.indexOf(\"?\");\r\n        if (queryStringPosition !== -1) {\r\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n        }\r\n        var dotPosition = sceneFilename.lastIndexOf(\".\");\r\n        var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n        return SceneLoader._GetPluginForExtension(extension);\r\n    };\r\n    SceneLoader._GetDirectLoad = function (sceneFilename) {\r\n        if (sceneFilename.substr(0, 5) === \"data:\") {\r\n            return sceneFilename.substr(5);\r\n        }\r\n        return null;\r\n    };\r\n    SceneLoader._LoadData = function (fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\r\n        var directLoad = SceneLoader._GetDirectLoad(fileInfo.name);\r\n        var registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : (directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.name) : SceneLoader._GetPluginForFilename(fileInfo.name));\r\n        var plugin;\r\n        if (registeredPlugin.plugin.createPlugin !== undefined) {\r\n            plugin = registeredPlugin.plugin.createPlugin();\r\n        }\r\n        else {\r\n            plugin = registeredPlugin.plugin;\r\n        }\r\n        if (!plugin) {\r\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\r\n        }\r\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\r\n        if (directLoad) {\r\n            if (plugin.directLoad) {\r\n                var result = plugin.directLoad(scene, directLoad);\r\n                if (result.then) {\r\n                    result.then(function (data) {\r\n                        onSuccess(plugin, data);\r\n                    }).catch(function (error) {\r\n                        onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                    });\r\n                }\r\n                else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            }\r\n            else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return plugin;\r\n        }\r\n        var useArrayBuffer = registeredPlugin.isBinary;\r\n        var dataCallback = function (data, responseURL) {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n        var request = null;\r\n        var pluginDisposed = false;\r\n        var onDisposeObservable = plugin.onDisposeObservable;\r\n        if (onDisposeObservable) {\r\n            onDisposeObservable.add(function () {\r\n                pluginDisposed = true;\r\n                if (request) {\r\n                    request.abort();\r\n                    request = null;\r\n                }\r\n                onDispose();\r\n            });\r\n        }\r\n        var manifestChecked = function () {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n            var successCallback = function (data, request) {\r\n                dataCallback(data, request ? request.responseURL : undefined);\r\n            };\r\n            var errorCallback = function (error) {\r\n                onError(error.message, error);\r\n            };\r\n            request = plugin.requestFile\r\n                ? plugin.requestFile(scene, fileInfo.url, successCallback, onProgress, useArrayBuffer, errorCallback)\r\n                : scene._requestFile(fileInfo.url, successCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n        var file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];\r\n        if (fileInfo.rootUrl.indexOf(\"file:\") === -1 || (fileInfo.rootUrl.indexOf(\"file:\") !== -1 && !file)) {\r\n            var engine = scene.getEngine();\r\n            var canUseOfflineSupport = engine.enableOfflineSupport;\r\n            if (canUseOfflineSupport) {\r\n                // Also check for exceptions\r\n                var exceptionFound = false;\r\n                for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {\r\n                    var regex = _a[_i];\r\n                    if (regex.test(fileInfo.url)) {\r\n                        exceptionFound = true;\r\n                        break;\r\n                    }\r\n                }\r\n                canUseOfflineSupport = !exceptionFound;\r\n            }\r\n            if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\r\n                // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n                scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n            }\r\n            else {\r\n                manifestChecked();\r\n            }\r\n        }\r\n        // Loading file from disk via input file or drag'n'drop\r\n        else {\r\n            if (file) {\r\n                var errorCallback = function (error) {\r\n                    onError(error.message, error);\r\n                };\r\n                request = plugin.readFile\r\n                    ? plugin.readFile(scene, file, dataCallback, onProgress, useArrayBuffer, errorCallback)\r\n                    : scene._readFile(file, dataCallback, onProgress, useArrayBuffer, errorCallback);\r\n            }\r\n            else {\r\n                onError(\"Unable to find file named \" + fileInfo.name);\r\n            }\r\n        }\r\n        return plugin;\r\n    };\r\n    SceneLoader._GetFileInfo = function (rootUrl, sceneFilename) {\r\n        var url;\r\n        var name;\r\n        var file = null;\r\n        if (!sceneFilename) {\r\n            url = rootUrl;\r\n            name = Tools.GetFilename(rootUrl);\r\n            rootUrl = Tools.GetFolderPath(rootUrl);\r\n        }\r\n        else if (sceneFilename.name) {\r\n            var sceneFile = sceneFilename;\r\n            url = rootUrl + sceneFile.name;\r\n            name = sceneFile.name;\r\n            file = sceneFile;\r\n        }\r\n        else {\r\n            var filename = sceneFilename;\r\n            if (filename.substr(0, 1) === \"/\") {\r\n                Tools.Error(\"Wrong sceneFilename parameter\");\r\n                return null;\r\n            }\r\n            url = rootUrl + filename;\r\n            name = filename;\r\n        }\r\n        return {\r\n            url: url,\r\n            rootUrl: rootUrl,\r\n            name: name,\r\n            file: file\r\n        };\r\n    };\r\n    // Public functions\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    SceneLoader.GetPluginForExtension = function (extension) {\r\n        return SceneLoader._GetPluginForExtension(extension).plugin;\r\n    };\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    SceneLoader.IsPluginForExtensionAvailable = function (extension) {\r\n        return !!SceneLoader._registeredPlugins[extension];\r\n    };\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    SceneLoader.RegisterPlugin = function (plugin) {\r\n        if (typeof plugin.extensions === \"string\") {\r\n            var extension = plugin.extensions;\r\n            SceneLoader._registeredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: false\r\n            };\r\n        }\r\n        else {\r\n            var extensions = plugin.extensions;\r\n            Object.keys(extensions).forEach(function (extension) {\r\n                SceneLoader._registeredPlugins[extension.toLowerCase()] = {\r\n                    plugin: plugin,\r\n                    isBinary: extensions[extension].isBinary\r\n                };\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    SceneLoader.ImportMesh = function (meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (onSuccess === void 0) { onSuccess = null; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to import mesh to\");\r\n            return null;\r\n        }\r\n        var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n        var disposeHandler = function () {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n        var errorHandler = function (message, exception) {\r\n            var errorMessage = \"Unable to import meshes from \" + fileInfo.url + \": \" + message;\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            }\r\n            else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n            disposeHandler();\r\n        };\r\n        var progressHandler = onProgress ? function (event) {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback: \" + e, e);\r\n            }\r\n        } : undefined;\r\n        var successHandler = function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\r\n            scene.importedMeshesFiles.push(fileInfo.url);\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n                }\r\n            }\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n        return SceneLoader._LoadData(fileInfo, scene, function (plugin, data, responseURL) {\r\n            if (plugin.rewriteRootURL) {\r\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n            }\r\n            if (plugin.importMesh) {\r\n                var syncedPlugin = plugin;\r\n                var meshes = new Array();\r\n                var particleSystems = new Array();\r\n                var skeletons = new Array();\r\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                    return;\r\n                }\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(meshes, particleSystems, skeletons, [], [], [], []);\r\n            }\r\n            else {\r\n                var asyncedPlugin = plugin;\r\n                asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (result) {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\r\n                }).catch(function (error) {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    };\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    SceneLoader.ImportMeshAsync = function (meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        return new Promise(function (resolve, reject) {\r\n            SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: particleSystems,\r\n                    skeletons: skeletons,\r\n                    animationGroups: animationGroups,\r\n                    transformNodes: transformNodes,\r\n                    geometries: geometries,\r\n                    lights: lights\r\n                });\r\n            }, onProgress, function (scene, message, exception) {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    };\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    SceneLoader.Load = function (rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (engine === void 0) { engine = EngineStore.LastCreatedEngine; }\r\n        if (onSuccess === void 0) { onSuccess = null; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        if (!engine) {\r\n            Tools.Error(\"No engine available\");\r\n            return null;\r\n        }\r\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\r\n    };\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded scene\r\n     */\r\n    SceneLoader.LoadAsync = function (rootUrl, sceneFilename, engine, onProgress, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (engine === void 0) { engine = EngineStore.LastCreatedEngine; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        return new Promise(function (resolve, reject) {\r\n            SceneLoader.Load(rootUrl, sceneFilename, engine, function (scene) {\r\n                resolve(scene);\r\n            }, onProgress, function (scene, message, exception) {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    };\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    SceneLoader.Append = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\r\n        var _this = this;\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (onSuccess === void 0) { onSuccess = null; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to append to\");\r\n            return null;\r\n        }\r\n        var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n        if (SceneLoader.ShowLoadingScreen && !this._showingLoadingScreen) {\r\n            this._showingLoadingScreen = true;\r\n            scene.getEngine().displayLoadingUI();\r\n            scene.executeWhenReady(function () {\r\n                scene.getEngine().hideLoadingUI();\r\n                _this._showingLoadingScreen = false;\r\n            });\r\n        }\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n        var disposeHandler = function () {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n        var errorHandler = function (message, exception) {\r\n            var errorMessage = \"Unable to load from \" + fileInfo.url + (message ? \": \" + message : \"\");\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            }\r\n            else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n            disposeHandler();\r\n        };\r\n        var progressHandler = onProgress ? function (event) {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n        var successHandler = function () {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(scene);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n        return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\r\n            if (plugin.load) {\r\n                var syncedPlugin = plugin;\r\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                    return;\r\n                }\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler();\r\n            }\r\n            else {\r\n                var asyncedPlugin = plugin;\r\n                asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function () {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler();\r\n                }).catch(function (error) {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    };\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The given scene\r\n     */\r\n    SceneLoader.AppendAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        return new Promise(function (resolve, reject) {\r\n            SceneLoader.Append(rootUrl, sceneFilename, scene, function (scene) {\r\n                resolve(scene);\r\n            }, onProgress, function (scene, message, exception) {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    };\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    SceneLoader.LoadAssetContainer = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (onSuccess === void 0) { onSuccess = null; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load asset container to\");\r\n            return null;\r\n        }\r\n        var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n        var disposeHandler = function () {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n        var errorHandler = function (message, exception) {\r\n            var errorMessage = \"Unable to load assets from \" + fileInfo.url + (message ? \": \" + message : \"\");\r\n            if (exception && exception.message) {\r\n                errorMessage += \" (\" + exception.message + \")\";\r\n            }\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            }\r\n            else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n            disposeHandler();\r\n        };\r\n        var progressHandler = onProgress ? function (event) {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n        var successHandler = function (assets) {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(assets);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n        return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\r\n            if (plugin.loadAssetContainer) {\r\n                var syncedPlugin = plugin;\r\n                var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                if (!assetContainer) {\r\n                    return;\r\n                }\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(assetContainer);\r\n            }\r\n            else if (plugin.loadAssetContainerAsync) {\r\n                var asyncedPlugin = plugin;\r\n                asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (assetContainer) {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(assetContainer);\r\n                }).catch(function (error) {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n            else {\r\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    };\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded asset container\r\n     */\r\n    SceneLoader.LoadAssetContainerAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        return new Promise(function (resolve, reject) {\r\n            SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, function (assetContainer) {\r\n                resolve(assetContainer);\r\n            }, onProgress, function (scene, message, exception) {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    };\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     */\r\n    SceneLoader.ImportAnimations = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (overwriteAnimations === void 0) { overwriteAnimations = true; }\r\n        if (animationGroupLoadingMode === void 0) { animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean; }\r\n        if (targetConverter === void 0) { targetConverter = null; }\r\n        if (onSuccess === void 0) { onSuccess = null; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load animations to\");\r\n            return;\r\n        }\r\n        if (overwriteAnimations) {\r\n            // Reset, stop and dispose all animations before loading new ones\r\n            for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {\r\n                var animatable = _a[_i];\r\n                animatable.reset();\r\n            }\r\n            scene.stopAllAnimations();\r\n            scene.animationGroups.slice().forEach(function (animationGroup) {\r\n                animationGroup.dispose();\r\n            });\r\n            var nodes = scene.getNodes();\r\n            nodes.forEach(function (node) {\r\n                if (node.animations) {\r\n                    node.animations = [];\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            switch (animationGroupLoadingMode) {\r\n                case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                    scene.animationGroups.slice().forEach(function (animationGroup) {\r\n                        animationGroup.dispose();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                    scene.animationGroups.forEach(function (animationGroup) {\r\n                        animationGroup.stop();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                    scene.animationGroups.forEach(function (animationGroup) {\r\n                        animationGroup.reset();\r\n                        animationGroup.restart();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                    // nothing to do\r\n                    break;\r\n                default:\r\n                    Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                    return;\r\n            }\r\n        }\r\n        var startingIndexForNewAnimatables = scene.animatables.length;\r\n        var onAssetContainerLoaded = function (container) {\r\n            container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n            container.dispose();\r\n            scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n            if (onSuccess) {\r\n                onSuccess(scene);\r\n            }\r\n        };\r\n        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\r\n    };\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns the updated scene with imported animations\r\n     */\r\n    SceneLoader.ImportAnimationsAsync = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\r\n        if (sceneFilename === void 0) { sceneFilename = \"\"; }\r\n        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }\r\n        if (overwriteAnimations === void 0) { overwriteAnimations = true; }\r\n        if (animationGroupLoadingMode === void 0) { animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean; }\r\n        if (targetConverter === void 0) { targetConverter = null; }\r\n        if (onSuccess === void 0) { onSuccess = null; }\r\n        if (onProgress === void 0) { onProgress = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (pluginExtension === void 0) { pluginExtension = null; }\r\n        return new Promise(function (resolve, reject) {\r\n            SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function (_scene) {\r\n                resolve(_scene);\r\n            }, onProgress, function (_scene, message, exception) {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    };\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    SceneLoader.NO_LOGGING = 0;\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    SceneLoader.MINIMAL_LOGGING = 1;\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    SceneLoader.SUMMARY_LOGGING = 2;\r\n    /**\r\n     * Detailled logging while loading\r\n     */\r\n    SceneLoader.DETAILED_LOGGING = 3;\r\n    // Members\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    SceneLoader.OnPluginActivatedObservable = new Observable();\r\n    SceneLoader._registeredPlugins = {};\r\n    SceneLoader._showingLoadingScreen = false;\r\n    return SceneLoader;\r\n}());\r\nexport { SceneLoader };\r\n"]},"metadata":{},"sourceType":"module"}