{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { Logger } from \"../Misc/logger\";\nimport { _DevTools } from \"../Misc/devTools\";\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n */\n\nvar Sound =\n/** @class */\nfunction () {\n  /**\r\n   * Create a sound and attach it to a scene\r\n   * @param name Name of your sound\r\n   * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams\r\n   * @param scene defines the scene the sound belongs to\r\n   * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n   * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n   */\n  function Sound(name, urlOrArrayBuffer, scene, readyToPlayCallback, options) {\n    var _this = this;\n\n    if (readyToPlayCallback === void 0) {\n      readyToPlayCallback = null;\n    }\n\n    var _a, _b, _c, _d;\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\n\n\n    this.autoplay = false;\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\n\n    this.loop = false;\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\n\n    this.useCustomAttenuation = false;\n    /**\r\n     * Is this sound currently played.\r\n     */\n\n    this.isPlaying = false;\n    /**\r\n     * Is this sound currently paused.\r\n     */\n\n    this.isPaused = false;\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.spatialSound = false;\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.refDistance = 1;\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.rolloffFactor = 1;\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.maxDistance = 100;\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.distanceModel = \"linear\";\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\n\n    this.metadata = null;\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\n\n    this.onEndedObservable = new Observable();\n    this._panningModel = \"equalpower\";\n    this._playbackRate = 1;\n    this._streaming = false;\n    this._startTime = 0;\n    this._startOffset = 0;\n    this._position = Vector3.Zero();\n    /** @hidden */\n\n    this._positionInEmitterSpace = false;\n    this._localDirection = new Vector3(1, 0, 0);\n    this._volume = 1;\n    this._isReadyToPlay = false;\n    this._isDirectional = false; // Used if you'd like to create a directional sound.\n    // If not set, the sound will be omnidirectional\n\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._coneOuterGain = 0;\n    this._isOutputConnected = false;\n    this._urlType = \"Unknown\";\n    this.name = name;\n    this._scene = scene;\n\n    Sound._SceneComponentInitialization(scene);\n\n    this._readyToPlayCallback = readyToPlayCallback; // Default custom attenuation function is a linear attenuation\n\n    this._customAttenuationFunction = function (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {\n      if (currentDistance < maxDistance) {\n        return currentVolume * (1 - currentDistance / maxDistance);\n      } else {\n        return 0;\n      }\n    };\n\n    if (options) {\n      this.autoplay = options.autoplay || false;\n      this.loop = options.loop || false; // if volume === 0, we need another way to check this option\n\n      if (options.volume !== undefined) {\n        this._volume = options.volume;\n      }\n\n      this.spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;\n      this.rolloffFactor = options.rolloffFactor || 1;\n      this.refDistance = options.refDistance || 1;\n      this.distanceModel = options.distanceModel || \"linear\";\n      this._playbackRate = options.playbackRate || 1;\n      this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;\n      this._length = options.length;\n      this._offset = options.offset;\n    }\n\n    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\n      this._soundGain = Engine.audioEngine.audioContext.createGain();\n      this._soundGain.gain.value = this._volume;\n      this._inputAudioNode = this._soundGain;\n      this._outputAudioNode = this._soundGain;\n\n      if (this.spatialSound) {\n        this._createSpatialParameters();\n      }\n\n      this._scene.mainSoundTrack.addSound(this);\n\n      var validParameter = true; // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n\n      if (urlOrArrayBuffer) {\n        try {\n          if (typeof urlOrArrayBuffer === \"string\") {\n            this._urlType = \"String\";\n          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n            this._urlType = \"ArrayBuffer\";\n          } else if (urlOrArrayBuffer instanceof MediaStream) {\n            this._urlType = \"MediaStream\";\n          } else if (Array.isArray(urlOrArrayBuffer)) {\n            this._urlType = \"Array\";\n          }\n\n          var urls = [];\n          var codecSupportedFound = false;\n\n          switch (this._urlType) {\n            case \"MediaStream\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\n\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n\n              break;\n\n            case \"ArrayBuffer\":\n              if (urlOrArrayBuffer.byteLength > 0) {\n                codecSupportedFound = true;\n\n                this._soundLoaded(urlOrArrayBuffer);\n              }\n\n              break;\n\n            case \"String\":\n              urls.push(urlOrArrayBuffer);\n\n            case \"Array\":\n              if (urls.length === 0) {\n                urls = urlOrArrayBuffer;\n              } // If we found a supported format, we load it immediately and stop the loop\n\n\n              for (var i = 0; i < urls.length; i++) {\n                var url = urls[i];\n                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(\".wav\", url.length - 4) !== -1 || url.indexOf(\".m4a\", url.length - 4) !== -1 || url.indexOf(\"blob:\") !== -1;\n\n                if (codecSupportedFound) {\n                  // Loading sound using XHR2\n                  if (!this._streaming) {\n                    this._scene._loadFile(url, function (data) {\n                      _this._soundLoaded(data);\n                    }, undefined, true, true, function (exception) {\n                      if (exception) {\n                        Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\n                      }\n\n                      Logger.Error(\"Sound creation aborted.\");\n\n                      _this._scene.mainSoundTrack.removeSound(_this);\n                    });\n                  } // Streaming sound using HTML5 Audio tag\n                  else {\n                    this._htmlAudioElement = new Audio(url);\n                    this._htmlAudioElement.controls = false;\n                    this._htmlAudioElement.loop = this.loop;\n                    Tools.SetCorsBehavior(url, this._htmlAudioElement);\n                    this._htmlAudioElement.preload = \"auto\";\n\n                    this._htmlAudioElement.addEventListener(\"canplaythrough\", function () {\n                      _this._isReadyToPlay = true;\n\n                      if (_this.autoplay) {\n                        _this.play(0, _this._offset, _this._length);\n                      }\n\n                      if (_this._readyToPlayCallback) {\n                        _this._readyToPlayCallback();\n                      }\n                    });\n\n                    document.body.appendChild(this._htmlAudioElement);\n\n                    this._htmlAudioElement.load();\n                  }\n\n                  break;\n                }\n              }\n\n              break;\n\n            default:\n              validParameter = false;\n              break;\n          }\n\n          if (!validParameter) {\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n          } else {\n            if (!codecSupportedFound) {\n              this._isReadyToPlay = true; // Simulating a ready to play event to avoid breaking code path\n\n              if (this._readyToPlayCallback) {\n                window.setTimeout(function () {\n                  if (_this._readyToPlayCallback) {\n                    _this._readyToPlayCallback();\n                  }\n                }, 1000);\n              }\n            }\n          }\n        } catch (ex) {\n          Logger.Error(\"Unexpected error. Sound creation aborted.\");\n\n          this._scene.mainSoundTrack.removeSound(this);\n        }\n      }\n    } else {\n      // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n      this._scene.mainSoundTrack.addSound(this);\n\n      if (!Engine.audioEngine.WarnedWebAudioUnsupported) {\n        Logger.Error(\"Web Audio is not supported by your browser.\");\n        Engine.audioEngine.WarnedWebAudioUnsupported = true;\n      } // Simulating a ready to play event to avoid breaking code for non web audio browsers\n\n\n      if (this._readyToPlayCallback) {\n        window.setTimeout(function () {\n          if (_this._readyToPlayCallback) {\n            _this._readyToPlayCallback();\n          }\n        }, 1000);\n      }\n    }\n  }\n\n  Object.defineProperty(Sound.prototype, \"currentTime\", {\n    /**\r\n     * Gets the current time for the sound.\r\n     */\n    get: function () {\n      if (this._htmlAudioElement) {\n        return this._htmlAudioElement.currentTime;\n      }\n\n      var currentTime = this._startOffset;\n\n      if (this.isPlaying && Engine.audioEngine.audioContext) {\n        currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n\n      return currentTime;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Release the sound and its associated resources\r\n   */\n\n  Sound.prototype.dispose = function () {\n    if (Engine.audioEngine.canUseWebAudio) {\n      if (this.isPlaying) {\n        this.stop();\n      }\n\n      this._isReadyToPlay = false;\n\n      if (this.soundTrackId === -1) {\n        this._scene.mainSoundTrack.removeSound(this);\n      } else if (this._scene.soundTracks) {\n        this._scene.soundTracks[this.soundTrackId].removeSound(this);\n      }\n\n      if (this._soundGain) {\n        this._soundGain.disconnect();\n\n        this._soundGain = null;\n      }\n\n      if (this._soundPanner) {\n        this._soundPanner.disconnect();\n\n        this._soundPanner = null;\n      }\n\n      if (this._soundSource) {\n        this._soundSource.disconnect();\n\n        this._soundSource = null;\n      }\n\n      this._audioBuffer = null;\n\n      if (this._htmlAudioElement) {\n        this._htmlAudioElement.pause();\n\n        this._htmlAudioElement.src = \"\";\n        document.body.removeChild(this._htmlAudioElement);\n      }\n\n      if (this._streamingSource) {\n        this._streamingSource.disconnect();\n      }\n\n      if (this._connectedTransformNode && this._registerFunc) {\n        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n        this._connectedTransformNode = null;\n      }\n    }\n  };\n  /**\r\n   * Gets if the sounds is ready to be played or not.\r\n   * @returns true if ready, otherwise false\r\n   */\n\n\n  Sound.prototype.isReady = function () {\n    return this._isReadyToPlay;\n  };\n\n  Sound.prototype._soundLoaded = function (audioData) {\n    var _this = this;\n\n    if (!Engine.audioEngine.audioContext) {\n      return;\n    }\n\n    Engine.audioEngine.audioContext.decodeAudioData(audioData, function (buffer) {\n      _this._audioBuffer = buffer;\n      _this._isReadyToPlay = true;\n\n      if (_this.autoplay) {\n        _this.play(0, _this._offset, _this._length);\n      }\n\n      if (_this._readyToPlayCallback) {\n        _this._readyToPlayCallback();\n      }\n    }, function (err) {\n      Logger.Error(\"Error while decoding audio data for: \" + _this.name + \" / Error: \" + err);\n    });\n  };\n  /**\r\n   * Sets the data of the sound from an audiobuffer\r\n   * @param audioBuffer The audioBuffer containing the data\r\n   */\n\n\n  Sound.prototype.setAudioBuffer = function (audioBuffer) {\n    if (Engine.audioEngine.canUseWebAudio) {\n      this._audioBuffer = audioBuffer;\n      this._isReadyToPlay = true;\n    }\n  };\n  /**\r\n   * Updates the current sounds options such as maxdistance, loop...\r\n   * @param options A JSON object containing values named as the object properties\r\n   */\n\n\n  Sound.prototype.updateOptions = function (options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    if (options) {\n      this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;\n      this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;\n      this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;\n      this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;\n      this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;\n      this._length = (_h = options.length) !== null && _h !== void 0 ? _h : undefined;\n      this._offset = (_j = options.offset) !== null && _j !== void 0 ? _j : undefined;\n\n      this._updateSpatialParameters();\n\n      if (this.isPlaying) {\n        if (this._streaming && this._htmlAudioElement) {\n          this._htmlAudioElement.playbackRate = this._playbackRate;\n\n          if (this._htmlAudioElement.loop !== this.loop) {\n            this._htmlAudioElement.loop = this.loop;\n          }\n        } else {\n          if (this._soundSource) {\n            this._soundSource.playbackRate.value = this._playbackRate;\n\n            if (this._soundSource.loop !== this.loop) {\n              this._soundSource.loop = this.loop;\n            }\n\n            if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\n              this._soundSource.loopStart = this._offset;\n            }\n\n            if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\n              this._soundSource.loopEnd = (this._offset | 0) + this._length;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  Sound.prototype._createSpatialParameters = function () {\n    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\n      if (this._scene.headphone) {\n        this._panningModel = \"HRTF\";\n      }\n\n      this._soundPanner = Engine.audioEngine.audioContext.createPanner();\n\n      if (this._soundPanner && this._outputAudioNode) {\n        this._updateSpatialParameters();\n\n        this._soundPanner.connect(this._outputAudioNode);\n\n        this._inputAudioNode = this._soundPanner;\n      }\n    }\n  };\n\n  Sound.prototype._updateSpatialParameters = function () {\n    if (this.spatialSound && this._soundPanner) {\n      if (this.useCustomAttenuation) {\n        // Tricks to disable in a way embedded Web Audio attenuation\n        this._soundPanner.distanceModel = \"linear\";\n        this._soundPanner.maxDistance = Number.MAX_VALUE;\n        this._soundPanner.refDistance = 1;\n        this._soundPanner.rolloffFactor = 1;\n        this._soundPanner.panningModel = this._panningModel;\n      } else {\n        this._soundPanner.distanceModel = this.distanceModel;\n        this._soundPanner.maxDistance = this.maxDistance;\n        this._soundPanner.refDistance = this.refDistance;\n        this._soundPanner.rolloffFactor = this.rolloffFactor;\n        this._soundPanner.panningModel = this._panningModel;\n      }\n    }\n  };\n  /**\r\n   * Switch the panning model to HRTF:\r\n   * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n   */\n\n\n  Sound.prototype.switchPanningModelToHRTF = function () {\n    this._panningModel = \"HRTF\";\n\n    this._switchPanningModel();\n  };\n  /**\r\n   * Switch the panning model to Equal Power:\r\n   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n   */\n\n\n  Sound.prototype.switchPanningModelToEqualPower = function () {\n    this._panningModel = \"equalpower\";\n\n    this._switchPanningModel();\n  };\n\n  Sound.prototype._switchPanningModel = function () {\n    if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\n      this._soundPanner.panningModel = this._panningModel;\n    }\n  };\n  /**\r\n   * Connect this sound to a sound track audio node like gain...\r\n   * @param soundTrackAudioNode the sound track audio node to connect to\r\n   */\n\n\n  Sound.prototype.connectToSoundTrackAudioNode = function (soundTrackAudioNode) {\n    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\n      if (this._isOutputConnected) {\n        this._outputAudioNode.disconnect();\n      }\n\n      this._outputAudioNode.connect(soundTrackAudioNode);\n\n      this._isOutputConnected = true;\n    }\n  };\n  /**\r\n   * Transform this sound into a directional source\r\n   * @param coneInnerAngle Size of the inner cone in degree\r\n   * @param coneOuterAngle Size of the outer cone in degree\r\n   * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n   */\n\n\n  Sound.prototype.setDirectionalCone = function (coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    if (coneOuterAngle < coneInnerAngle) {\n      Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n      return;\n    }\n\n    this._coneInnerAngle = coneInnerAngle;\n    this._coneOuterAngle = coneOuterAngle;\n    this._coneOuterGain = coneOuterGain;\n    this._isDirectional = true;\n\n    if (this.isPlaying && this.loop) {\n      this.stop();\n      this.play(0, this._offset, this._length);\n    }\n  };\n\n  Object.defineProperty(Sound.prototype, \"directionalConeInnerAngle\", {\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\n    get: function () {\n      return this._coneInnerAngle;\n    },\n\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\n    set: function (value) {\n      if (value != this._coneInnerAngle) {\n        if (this._coneOuterAngle < value) {\n          Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneInnerAngle = value;\n\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\n          this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sound.prototype, \"directionalConeOuterAngle\", {\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\n    get: function () {\n      return this._coneOuterAngle;\n    },\n\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\n    set: function (value) {\n      if (value != this._coneOuterAngle) {\n        if (value < this._coneInnerAngle) {\n          Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneOuterAngle = value;\n\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\n          this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the position of the emitter if spatial sound is enabled\r\n   * @param newPosition Defines the new posisiton\r\n   */\n\n  Sound.prototype.setPosition = function (newPosition) {\n    this._position = newPosition;\n\n    if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n      this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n    }\n  };\n  /**\r\n   * Sets the local direction of the emitter if spatial sound is enabled\r\n   * @param newLocalDirection Defines the new local direction\r\n   */\n\n\n  Sound.prototype.setLocalDirectionToMesh = function (newLocalDirection) {\n    this._localDirection = newLocalDirection;\n\n    if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\n      this._updateDirection();\n    }\n  };\n\n  Sound.prototype._updateDirection = function () {\n    if (!this._connectedTransformNode || !this._soundPanner) {\n      return;\n    }\n\n    var mat = this._connectedTransformNode.getWorldMatrix();\n\n    var direction = Vector3.TransformNormal(this._localDirection, mat);\n    direction.normalize();\n\n    this._soundPanner.setOrientation(direction.x, direction.y, direction.z);\n  };\n  /** @hidden */\n\n\n  Sound.prototype.updateDistanceFromListener = function () {\n    if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n      var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n\n      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n    }\n  };\n  /**\r\n   * Sets a new custom attenuation function for the sound.\r\n   * @param callback Defines the function used for the attenuation\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n   */\n\n\n  Sound.prototype.setAttenuationFunction = function (callback) {\n    this._customAttenuationFunction = callback;\n  };\n  /**\r\n   * Play the sound\r\n   * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n   * @param offset (optional) Start the sound at a specific time in seconds\r\n   * @param length (optional) Sound duration (in seconds)\r\n   */\n\n\n  Sound.prototype.play = function (time, offset, length) {\n    var _this = this;\n\n    if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine.audioContext) {\n      try {\n        if (this._startOffset < 0) {\n          time = -this._startOffset;\n          this._startOffset = 0;\n        }\n\n        var startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\n\n        if (!this._soundSource || !this._streamingSource) {\n          if (this.spatialSound && this._soundPanner) {\n            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n              this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n            }\n\n            if (this._isDirectional) {\n              this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n              this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n              this._soundPanner.coneOuterGain = this._coneOuterGain;\n\n              if (this._connectedTransformNode) {\n                this._updateDirection();\n              } else {\n                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n              }\n            }\n          }\n        }\n\n        if (this._streaming) {\n          if (!this._streamingSource) {\n            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n\n            this._htmlAudioElement.onended = function () {\n              _this._onended();\n            };\n\n            this._htmlAudioElement.playbackRate = this._playbackRate;\n          }\n\n          this._streamingSource.disconnect();\n\n          if (this._inputAudioNode) {\n            this._streamingSource.connect(this._inputAudioNode);\n          }\n\n          if (this._htmlAudioElement) {\n            // required to manage properly the new suspended default state of Chrome\n            // When the option 'streaming: true' is used, we need first to wait for\n            // the audio engine to be unlocked by a user gesture before trying to play\n            // an HTML Audio elememt\n            var tryToPlay = function () {\n              if (Engine.audioEngine.unlocked) {\n                var playPromise = _this._htmlAudioElement.play(); // In browsers that don’t yet support this functionality,\n                // playPromise won’t be defined.\n\n\n                if (playPromise !== undefined) {\n                  playPromise.catch(function (error) {\n                    // Automatic playback failed.\n                    // Waiting for the audio engine to be unlocked by user click on unmute\n                    Engine.audioEngine.lock();\n\n                    if (_this.loop || _this.autoplay) {\n                      Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                        tryToPlay();\n                      });\n                    }\n                  });\n                }\n              } else {\n                if (_this.loop || _this.autoplay) {\n                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                    tryToPlay();\n                  });\n                }\n              }\n            };\n\n            tryToPlay();\n          }\n        } else {\n          var tryToPlay = function () {\n            if (Engine.audioEngine.audioContext) {\n              length = length || _this._length;\n              offset = offset || _this._offset;\n\n              if (_this._soundSource) {\n                var oldSource_1 = _this._soundSource;\n\n                oldSource_1.onended = function () {\n                  oldSource_1.disconnect();\n                };\n              }\n\n              _this._soundSource = Engine.audioEngine.audioContext.createBufferSource();\n\n              if (_this._soundSource && _this._inputAudioNode) {\n                _this._soundSource.buffer = _this._audioBuffer;\n\n                _this._soundSource.connect(_this._inputAudioNode);\n\n                _this._soundSource.loop = _this.loop;\n\n                if (offset !== undefined) {\n                  _this._soundSource.loopStart = offset;\n                }\n\n                if (length !== undefined) {\n                  _this._soundSource.loopEnd = (offset | 0) + length;\n                }\n\n                _this._soundSource.playbackRate.value = _this._playbackRate;\n\n                _this._soundSource.onended = function () {\n                  _this._onended();\n                };\n\n                startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\n                var actualOffset = _this.isPaused ? _this._startOffset % _this._soundSource.buffer.duration : offset ? offset : 0;\n\n                _this._soundSource.start(startTime, actualOffset, _this.loop ? undefined : length);\n              }\n            }\n          };\n\n          if (Engine.audioEngine.audioContext.state === \"suspended\") {\n            // Wait a bit for FF as context seems late to be ready.\n            setTimeout(function () {\n              if (Engine.audioEngine.audioContext.state === \"suspended\") {\n                // Automatic playback failed.\n                // Waiting for the audio engine to be unlocked by user click on unmute\n                Engine.audioEngine.lock();\n\n                if (_this.loop || _this.autoplay) {\n                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                    tryToPlay();\n                  });\n                }\n              } else {\n                tryToPlay();\n              }\n            }, 500);\n          } else {\n            tryToPlay();\n          }\n        }\n\n        this._startTime = startTime;\n        this.isPlaying = true;\n        this.isPaused = false;\n      } catch (ex) {\n        Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n      }\n    }\n  };\n\n  Sound.prototype._onended = function () {\n    this.isPlaying = false;\n    this._startOffset = 0;\n\n    if (this.onended) {\n      this.onended();\n    }\n\n    this.onEndedObservable.notifyObservers(this);\n  };\n  /**\r\n   * Stop the sound\r\n   * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n   */\n\n\n  Sound.prototype.stop = function (time) {\n    var _this = this;\n\n    if (this.isPlaying) {\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause(); // Test needed for Firefox or it will generate an Invalid State Error\n\n\n          if (this._htmlAudioElement.currentTime > 0) {\n            this._htmlAudioElement.currentTime = 0;\n          }\n        } else {\n          this._streamingSource.disconnect();\n        }\n\n        this.isPlaying = false;\n      } else if (Engine.audioEngine.audioContext && this._soundSource) {\n        var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\n\n        this._soundSource.stop(stopTime);\n\n        this._soundSource.onended = function () {\n          _this.isPlaying = false;\n        };\n\n        if (!this.isPaused) {\n          this._startOffset = 0;\n        }\n      }\n    }\n  };\n  /**\r\n   * Put the sound in pause\r\n   */\n\n\n  Sound.prototype.pause = function () {\n    if (this.isPlaying) {\n      this.isPaused = true;\n\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n        } else {\n          this._streamingSource.disconnect();\n        }\n      } else if (Engine.audioEngine.audioContext) {\n        this.stop(0);\n        this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n    }\n  };\n  /**\r\n   * Sets a dedicated volume for this sounds\r\n   * @param newVolume Define the new volume of the sound\r\n   * @param time Define time for gradual change to new volume\r\n   */\n\n\n  Sound.prototype.setVolume = function (newVolume, time) {\n    if (Engine.audioEngine.canUseWebAudio && this._soundGain) {\n      if (time && Engine.audioEngine.audioContext) {\n        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\n\n        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\n\n        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\n      } else {\n        this._soundGain.gain.value = newVolume;\n      }\n    }\n\n    this._volume = newVolume;\n  };\n  /**\r\n   * Set the sound play back rate\r\n   * @param newPlaybackRate Define the playback rate the sound should be played at\r\n   */\n\n\n  Sound.prototype.setPlaybackRate = function (newPlaybackRate) {\n    this._playbackRate = newPlaybackRate;\n\n    if (this.isPlaying) {\n      if (this._streaming && this._htmlAudioElement) {\n        this._htmlAudioElement.playbackRate = this._playbackRate;\n      } else if (this._soundSource) {\n        this._soundSource.playbackRate.value = this._playbackRate;\n      }\n    }\n  };\n  /**\r\n   * Gets the volume of the sound.\r\n   * @returns the volume of the sound\r\n   */\n\n\n  Sound.prototype.getVolume = function () {\n    return this._volume;\n  };\n  /**\r\n   * Attach the sound to a dedicated mesh\r\n   * @param transformNode The transform node to connect the sound with\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n   */\n\n\n  Sound.prototype.attachToMesh = function (transformNode) {\n    var _this = this;\n\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n      this._registerFunc = null;\n    }\n\n    this._connectedTransformNode = transformNode;\n\n    if (!this.spatialSound) {\n      this.spatialSound = true;\n\n      this._createSpatialParameters();\n\n      if (this.isPlaying && this.loop) {\n        this.stop();\n        this.play(0, this._offset, this._length);\n      }\n    }\n\n    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n\n    this._registerFunc = function (transformNode) {\n      return _this._onRegisterAfterWorldMatrixUpdate(transformNode);\n    };\n\n    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n  };\n  /**\r\n   * Detach the sound from the previously attached mesh\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n   */\n\n\n  Sound.prototype.detachFromMesh = function () {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n      this._registerFunc = null;\n      this._connectedTransformNode = null;\n    }\n  };\n\n  Sound.prototype._onRegisterAfterWorldMatrixUpdate = function (node) {\n    if (this._positionInEmitterSpace) {\n      node.worldMatrixFromCache.invertToRef(TmpVectors.Matrix[0]);\n      this.setPosition(TmpVectors.Matrix[0].getTranslation());\n    } else {\n      if (!node.getBoundingInfo) {\n        this.setPosition(node.absolutePosition);\n      } else {\n        var mesh = node;\n        var boundingInfo = mesh.getBoundingInfo();\n        this.setPosition(boundingInfo.boundingSphere.centerWorld);\n      }\n    }\n\n    if (Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying) {\n      this._updateDirection();\n    }\n  };\n  /**\r\n   * Clone the current sound in the scene.\r\n   * @returns the new sound clone\r\n   */\n\n\n  Sound.prototype.clone = function () {\n    var _this = this;\n\n    if (!this._streaming) {\n      var setBufferAndRun = function () {\n        if (_this._isReadyToPlay) {\n          clonedSound._audioBuffer = _this.getAudioBuffer();\n          clonedSound._isReadyToPlay = true;\n\n          if (clonedSound.autoplay) {\n            clonedSound.play(0, _this._offset, _this._length);\n          }\n        } else {\n          window.setTimeout(setBufferAndRun, 300);\n        }\n      };\n\n      var currentOptions = {\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this.spatialSound,\n        maxDistance: this.maxDistance,\n        useCustomAttenuation: this.useCustomAttenuation,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel\n      };\n      var clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n\n      if (this.useCustomAttenuation) {\n        clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n      }\n\n      clonedSound.setPosition(this._position);\n      clonedSound.setPlaybackRate(this._playbackRate);\n      setBufferAndRun();\n      return clonedSound;\n    } // Can't clone a streaming sound\n    else {\n      return null;\n    }\n  };\n  /**\r\n   * Gets the current underlying audio buffer containing the data\r\n   * @returns the audio buffer\r\n   */\n\n\n  Sound.prototype.getAudioBuffer = function () {\n    return this._audioBuffer;\n  };\n  /**\r\n   * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n   * @returns the source node\r\n   */\n\n\n  Sound.prototype.getSoundSource = function () {\n    return this._soundSource;\n  };\n  /**\r\n   * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n   * @returns the gain node\r\n   */\n\n\n  Sound.prototype.getSoundGain = function () {\n    return this._soundGain;\n  };\n  /**\r\n   * Serializes the Sound in a JSON representation\r\n   * @returns the JSON representation of the sound\r\n   */\n\n\n  Sound.prototype.serialize = function () {\n    var serializationObject = {\n      name: this.name,\n      url: this.name,\n      autoplay: this.autoplay,\n      loop: this.loop,\n      volume: this._volume,\n      spatialSound: this.spatialSound,\n      maxDistance: this.maxDistance,\n      rolloffFactor: this.rolloffFactor,\n      refDistance: this.refDistance,\n      distanceModel: this.distanceModel,\n      playbackRate: this._playbackRate,\n      panningModel: this._panningModel,\n      soundTrackId: this.soundTrackId,\n      metadata: this.metadata\n    };\n\n    if (this.spatialSound) {\n      if (this._connectedTransformNode) {\n        serializationObject.connectedMeshId = this._connectedTransformNode.id;\n      }\n\n      serializationObject.position = this._position.asArray();\n      serializationObject.refDistance = this.refDistance;\n      serializationObject.distanceModel = this.distanceModel;\n      serializationObject.isDirectional = this._isDirectional;\n      serializationObject.localDirectionToMesh = this._localDirection.asArray();\n      serializationObject.coneInnerAngle = this._coneInnerAngle;\n      serializationObject.coneOuterAngle = this._coneOuterAngle;\n      serializationObject.coneOuterGain = this._coneOuterGain;\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Parse a JSON representation of a sound to innstantiate in a given scene\r\n   * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n   * @param scene Define the scene the new parsed sound should be created in\r\n   * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n   * @param sourceSound Define a cound place holder if do not need to instantiate a new one\r\n   * @returns the newly parsed sound\r\n   */\n\n\n  Sound.Parse = function (parsedSound, scene, rootUrl, sourceSound) {\n    var soundName = parsedSound.name;\n    var soundUrl;\n\n    if (parsedSound.url) {\n      soundUrl = rootUrl + parsedSound.url;\n    } else {\n      soundUrl = rootUrl + soundName;\n    }\n\n    var options = {\n      autoplay: parsedSound.autoplay,\n      loop: parsedSound.loop,\n      volume: parsedSound.volume,\n      spatialSound: parsedSound.spatialSound,\n      maxDistance: parsedSound.maxDistance,\n      rolloffFactor: parsedSound.rolloffFactor,\n      refDistance: parsedSound.refDistance,\n      distanceModel: parsedSound.distanceModel,\n      playbackRate: parsedSound.playbackRate\n    };\n    var newSound;\n\n    if (!sourceSound) {\n      newSound = new Sound(soundName, soundUrl, scene, function () {\n        scene._removePendingData(newSound);\n      }, options);\n\n      scene._addPendingData(newSound);\n    } else {\n      var setBufferAndRun = function () {\n        if (sourceSound._isReadyToPlay) {\n          newSound._audioBuffer = sourceSound.getAudioBuffer();\n          newSound._isReadyToPlay = true;\n\n          if (newSound.autoplay) {\n            newSound.play(0, newSound._offset, newSound._length);\n          }\n        } else {\n          window.setTimeout(setBufferAndRun, 300);\n        }\n      };\n\n      newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n      setBufferAndRun();\n    }\n\n    if (parsedSound.position) {\n      var soundPosition = Vector3.FromArray(parsedSound.position);\n      newSound.setPosition(soundPosition);\n    }\n\n    if (parsedSound.isDirectional) {\n      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n\n      if (parsedSound.localDirectionToMesh) {\n        var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n        newSound.setLocalDirectionToMesh(localDirectionToMesh);\n      }\n    }\n\n    if (parsedSound.connectedMeshId) {\n      var connectedMesh = scene.getMeshByID(parsedSound.connectedMeshId);\n\n      if (connectedMesh) {\n        newSound.attachToMesh(connectedMesh);\n      }\n    }\n\n    if (parsedSound.metadata) {\n      newSound.metadata = parsedSound.metadata;\n    }\n\n    return newSound;\n  };\n  /** @hidden */\n\n\n  Sound._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"AudioSceneComponent\");\n  };\n\n  return Sound;\n}();\n\nexport { Sound };","map":{"version":3,"sources":["C:/Users/rober/Documents/Computer Science/Side Projects/arcade/node_modules/@babylonjs/core/Audio/sound.js"],"names":["Tools","Observable","Vector3","TmpVectors","Engine","Logger","_DevTools","Sound","name","urlOrArrayBuffer","scene","readyToPlayCallback","options","_this","_a","_b","_c","_d","autoplay","loop","useCustomAttenuation","isPlaying","isPaused","spatialSound","refDistance","rolloffFactor","maxDistance","distanceModel","metadata","onEndedObservable","_panningModel","_playbackRate","_streaming","_startTime","_startOffset","_position","Zero","_positionInEmitterSpace","_localDirection","_volume","_isReadyToPlay","_isDirectional","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_isOutputConnected","_urlType","_scene","_SceneComponentInitialization","_readyToPlayCallback","_customAttenuationFunction","currentVolume","currentDistance","volume","undefined","playbackRate","streaming","_length","length","_offset","offset","audioEngine","canUseWebAudio","audioContext","_soundGain","createGain","gain","value","_inputAudioNode","_outputAudioNode","_createSpatialParameters","mainSoundTrack","addSound","validParameter","ArrayBuffer","MediaStream","Array","isArray","urls","codecSupportedFound","_streamingSource","createMediaStreamSource","play","byteLength","_soundLoaded","push","i","url","skipCodecCheck","indexOf","isMP3supported","isOGGsupported","_loadFile","data","exception","Error","status","removeSound","_htmlAudioElement","Audio","controls","SetCorsBehavior","preload","addEventListener","document","body","appendChild","load","window","setTimeout","ex","WarnedWebAudioUnsupported","Object","defineProperty","prototype","get","currentTime","enumerable","configurable","dispose","stop","soundTrackId","soundTracks","disconnect","_soundPanner","_soundSource","_audioBuffer","pause","src","removeChild","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","isReady","audioData","decodeAudioData","buffer","err","setAudioBuffer","audioBuffer","updateOptions","_e","_f","_g","_h","_j","_updateSpatialParameters","loopStart","loopEnd","headphone","createPanner","connect","Number","MAX_VALUE","panningModel","switchPanningModelToHRTF","_switchPanningModel","switchPanningModelToEqualPower","connectToSoundTrackAudioNode","soundTrackAudioNode","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","set","setPosition","newPosition","isNaN","x","y","z","setLocalDirectionToMesh","newLocalDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","setOrientation","updateDistanceFromListener","activeCamera","distance","getDistanceToCamera","setAttenuationFunction","callback","time","audioEnabled","startTime","createMediaElementSource","onended","_onended","tryToPlay","unlocked","playPromise","catch","error","lock","onAudioUnlockedObservable","addOnce","oldSource_1","createBufferSource","actualOffset","duration","start","state","message","notifyObservers","stopTime","setVolume","newVolume","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","setPlaybackRate","newPlaybackRate","getVolume","attachToMesh","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","detachFromMesh","node","worldMatrixFromCache","invertToRef","Matrix","getTranslation","getBoundingInfo","absolutePosition","mesh","boundingInfo","boundingSphere","centerWorld","clone","setBufferAndRun","clonedSound","getAudioBuffer","currentOptions","getSoundSource","getSoundGain","serialize","serializationObject","connectedMeshId","id","position","asArray","isDirectional","localDirectionToMesh","Parse","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","_removePendingData","_addPendingData","soundPosition","FromArray","connectedMesh","getMeshByID","_","WarnImport"],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _DevTools } from \"../Misc/devTools\";\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n */\r\nvar Sound = /** @class */ (function () {\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    function Sound(name, urlOrArrayBuffer, scene, readyToPlayCallback, options) {\r\n        var _this = this;\r\n        if (readyToPlayCallback === void 0) { readyToPlayCallback = null; }\r\n        var _a, _b, _c, _d;\r\n        /**\r\n         * Does the sound autoplay once loaded.\r\n         */\r\n        this.autoplay = false;\r\n        /**\r\n         * Does the sound loop after it finishes playing once.\r\n         */\r\n        this.loop = false;\r\n        /**\r\n         * Does the sound use a custom attenuation curve to simulate the falloff\r\n         * happening when the source gets further away from the camera.\r\n         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n         */\r\n        this.useCustomAttenuation = false;\r\n        /**\r\n         * Is this sound currently played.\r\n         */\r\n        this.isPlaying = false;\r\n        /**\r\n         * Is this sound currently paused.\r\n         */\r\n        this.isPaused = false;\r\n        /**\r\n         * Does this sound enables spatial sound.\r\n         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n         */\r\n        this.spatialSound = false;\r\n        /**\r\n         * Define the reference distance the sound should be heard perfectly.\r\n         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n         */\r\n        this.refDistance = 1;\r\n        /**\r\n         * Define the roll off factor of spatial sounds.\r\n         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n         */\r\n        this.rolloffFactor = 1;\r\n        /**\r\n         * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n         */\r\n        this.maxDistance = 100;\r\n        /**\r\n         * Define the distance attenuation model the sound will follow.\r\n         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n         */\r\n        this.distanceModel = \"linear\";\r\n        /**\r\n         * Gets or sets an object used to store user defined information for the sound.\r\n         */\r\n        this.metadata = null;\r\n        /**\r\n         * Observable event when the current playing sound finishes.\r\n         */\r\n        this.onEndedObservable = new Observable();\r\n        this._panningModel = \"equalpower\";\r\n        this._playbackRate = 1;\r\n        this._streaming = false;\r\n        this._startTime = 0;\r\n        this._startOffset = 0;\r\n        this._position = Vector3.Zero();\r\n        /** @hidden */\r\n        this._positionInEmitterSpace = false;\r\n        this._localDirection = new Vector3(1, 0, 0);\r\n        this._volume = 1;\r\n        this._isReadyToPlay = false;\r\n        this._isDirectional = false;\r\n        // Used if you'd like to create a directional sound.\r\n        // If not set, the sound will be omnidirectional\r\n        this._coneInnerAngle = 360;\r\n        this._coneOuterAngle = 360;\r\n        this._coneOuterGain = 0;\r\n        this._isOutputConnected = false;\r\n        this._urlType = \"Unknown\";\r\n        this.name = name;\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        this._customAttenuationFunction = function (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this.loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this.spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;\r\n            this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;\r\n            this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n        if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._soundGain = Engine.audioEngine.audioContext.createGain();\r\n            this._soundGain.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this.spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            var validParameter = true;\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                    }\r\n                    else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    }\r\n                    else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    }\r\n                    else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n                    var urls = [];\r\n                    var codecSupportedFound = false;\r\n                    switch (this._urlType) {\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if (urlOrArrayBuffer.byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (var i = 0; i < urls.length; i++) {\r\n                                var url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                        (url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported) ||\r\n                                        (url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported) ||\r\n                                        url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                        url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                        url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound using XHR2\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(url, function (data) {\r\n                                            _this._soundLoaded(data);\r\n                                        }, undefined, true, true, function (exception) {\r\n                                            if (exception) {\r\n                                                Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                            }\r\n                                            Logger.Error(\"Sound creation aborted.\");\r\n                                            _this._scene.mainSoundTrack.removeSound(_this);\r\n                                        });\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", function () {\r\n                                            _this._isReadyToPlay = true;\r\n                                            if (_this.autoplay) {\r\n                                                _this.play(0, _this._offset, _this._length);\r\n                                            }\r\n                                            if (_this._readyToPlayCallback) {\r\n                                                _this._readyToPlayCallback();\r\n                                            }\r\n                                        });\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    }\r\n                    else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                window.setTimeout(function () {\r\n                                    if (_this._readyToPlayCallback) {\r\n                                        _this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (!Engine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                Engine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                window.setTimeout(function () {\r\n                    if (_this._readyToPlayCallback) {\r\n                        _this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(Sound.prototype, \"currentTime\", {\r\n        /**\r\n         * Gets the current time for the sound.\r\n         */\r\n        get: function () {\r\n            if (this._htmlAudioElement) {\r\n                return this._htmlAudioElement.currentTime;\r\n            }\r\n            var currentTime = this._startOffset;\r\n            if (this.isPlaying && Engine.audioEngine.audioContext) {\r\n                currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n            return currentTime;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    Sound.prototype.dispose = function () {\r\n        if (Engine.audioEngine.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            }\r\n            else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n            }\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n            }\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    Sound.prototype.isReady = function () {\r\n        return this._isReadyToPlay;\r\n    };\r\n    Sound.prototype._soundLoaded = function (audioData) {\r\n        var _this = this;\r\n        if (!Engine.audioEngine.audioContext) {\r\n            return;\r\n        }\r\n        Engine.audioEngine.audioContext.decodeAudioData(audioData, function (buffer) {\r\n            _this._audioBuffer = buffer;\r\n            _this._isReadyToPlay = true;\r\n            if (_this.autoplay) {\r\n                _this.play(0, _this._offset, _this._length);\r\n            }\r\n            if (_this._readyToPlayCallback) {\r\n                _this._readyToPlayCallback();\r\n            }\r\n        }, function (err) {\r\n            Logger.Error(\"Error while decoding audio data for: \" + _this.name + \" / Error: \" + err);\r\n        });\r\n    };\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    Sound.prototype.setAudioBuffer = function (audioBuffer) {\r\n        if (Engine.audioEngine.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    };\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    Sound.prototype.updateOptions = function (options) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n        if (options) {\r\n            this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;\r\n            this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;\r\n            this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;\r\n            this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;\r\n            this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;\r\n            this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;\r\n            this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;\r\n            this._length = (_h = options.length) !== null && _h !== void 0 ? _h : undefined;\r\n            this._offset = (_j = options.offset) !== null && _j !== void 0 ? _j : undefined;\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset | 0) + this._length;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Sound.prototype._createSpatialParameters = function () {\r\n        if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = Engine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    };\r\n    Sound.prototype._updateSpatialParameters = function () {\r\n        if (this.spatialSound && this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel;\r\n            }\r\n            else {\r\n                this._soundPanner.distanceModel = this.distanceModel;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    Sound.prototype.switchPanningModelToHRTF = function () {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    };\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    Sound.prototype.switchPanningModelToEqualPower = function () {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    };\r\n    Sound.prototype._switchPanningModel = function () {\r\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel;\r\n        }\r\n    };\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    Sound.prototype.connectToSoundTrackAudioNode = function (soundTrackAudioNode) {\r\n        if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    };\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    Sound.prototype.setDirectionalCone = function (coneInnerAngle, coneOuterAngle, coneOuterGain) {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    };\r\n    Object.defineProperty(Sound.prototype, \"directionalConeInnerAngle\", {\r\n        /**\r\n         * Gets or sets the inner angle for the directional cone.\r\n         */\r\n        get: function () {\r\n            return this._coneInnerAngle;\r\n        },\r\n        /**\r\n         * Gets or sets the inner angle for the directional cone.\r\n         */\r\n        set: function (value) {\r\n            if (value != this._coneInnerAngle) {\r\n                if (this._coneOuterAngle < value) {\r\n                    Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                    return;\r\n                }\r\n                this._coneInnerAngle = value;\r\n                if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\r\n                    this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                }\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Sound.prototype, \"directionalConeOuterAngle\", {\r\n        /**\r\n         * Gets or sets the outer angle for the directional cone.\r\n         */\r\n        get: function () {\r\n            return this._coneOuterAngle;\r\n        },\r\n        /**\r\n         * Gets or sets the outer angle for the directional cone.\r\n         */\r\n        set: function (value) {\r\n            if (value != this._coneOuterAngle) {\r\n                if (value < this._coneInnerAngle) {\r\n                    Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                    return;\r\n                }\r\n                this._coneOuterAngle = value;\r\n                if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\r\n                    this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                }\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new posisiton\r\n     */\r\n    Sound.prototype.setPosition = function (newPosition) {\r\n        this._position = newPosition;\r\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n            this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\r\n        }\r\n    };\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    Sound.prototype.setLocalDirectionToMesh = function (newLocalDirection) {\r\n        this._localDirection = newLocalDirection;\r\n        if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    };\r\n    Sound.prototype._updateDirection = function () {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n        var mat = this._connectedTransformNode.getWorldMatrix();\r\n        var direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.setOrientation(direction.x, direction.y, direction.z);\r\n    };\r\n    /** @hidden */\r\n    Sound.prototype.updateDistanceFromListener = function () {\r\n        if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    };\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\r\n    Sound.prototype.setAttenuationFunction = function (callback) {\r\n        this._customAttenuationFunction = callback;\r\n    };\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    Sound.prototype.play = function (time, offset, length) {\r\n        var _this = this;\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine.audioContext) {\r\n            try {\r\n                if (this._startOffset < 0) {\r\n                    time = -this._startOffset;\r\n                    this._startOffset = 0;\r\n                }\r\n                var startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this.spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            }\r\n                            else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource) {\r\n                        this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = function () {\r\n                            _this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    this._streamingSource.disconnect();\r\n                    if (this._inputAudioNode) {\r\n                        this._streamingSource.connect(this._inputAudioNode);\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio elememt\r\n                        var tryToPlay = function () {\r\n                            if (Engine.audioEngine.unlocked) {\r\n                                var playPromise = _this._htmlAudioElement.play();\r\n                                // In browsers that don’t yet support this functionality,\r\n                                // playPromise won’t be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    playPromise.catch(function (error) {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        Engine.audioEngine.lock();\r\n                                        if (_this.loop || _this.autoplay) {\r\n                                            Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (_this.loop || _this.autoplay) {\r\n                                    Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                else {\r\n                    var tryToPlay = function () {\r\n                        if (Engine.audioEngine.audioContext) {\r\n                            length = length || _this._length;\r\n                            offset = offset || _this._offset;\r\n                            if (_this._soundSource) {\r\n                                var oldSource_1 = _this._soundSource;\r\n                                oldSource_1.onended = function () {\r\n                                    oldSource_1.disconnect();\r\n                                };\r\n                            }\r\n                            _this._soundSource = Engine.audioEngine.audioContext.createBufferSource();\r\n                            if (_this._soundSource && _this._inputAudioNode) {\r\n                                _this._soundSource.buffer = _this._audioBuffer;\r\n                                _this._soundSource.connect(_this._inputAudioNode);\r\n                                _this._soundSource.loop = _this.loop;\r\n                                if (offset !== undefined) {\r\n                                    _this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    _this._soundSource.loopEnd = (offset | 0) + length;\r\n                                }\r\n                                _this._soundSource.playbackRate.value = _this._playbackRate;\r\n                                _this._soundSource.onended = function () {\r\n                                    _this._onended();\r\n                                };\r\n                                startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\r\n                                var actualOffset = _this.isPaused ? _this._startOffset % _this._soundSource.buffer.duration : offset ? offset : 0;\r\n                                _this._soundSource.start(startTime, actualOffset, _this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n                    if (Engine.audioEngine.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        setTimeout(function () {\r\n                            if (Engine.audioEngine.audioContext.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                Engine.audioEngine.lock();\r\n                                if (_this.loop || _this.autoplay) {\r\n                                    Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                            else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    }\r\n                    else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            }\r\n            catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    };\r\n    Sound.prototype._onended = function () {\r\n        this.isPlaying = false;\r\n        this._startOffset = 0;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    };\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    Sound.prototype.stop = function (time) {\r\n        var _this = this;\r\n        if (this.isPlaying) {\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                }\r\n                else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            }\r\n            else if (Engine.audioEngine.audioContext && this._soundSource) {\r\n                var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\r\n                this._soundSource.stop(stopTime);\r\n                this._soundSource.onended = function () {\r\n                    _this.isPlaying = false;\r\n                };\r\n                if (!this.isPaused) {\r\n                    this._startOffset = 0;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    Sound.prototype.pause = function () {\r\n        if (this.isPlaying) {\r\n            this.isPaused = true;\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                }\r\n                else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n            }\r\n            else if (Engine.audioEngine.audioContext) {\r\n                this.stop(0);\r\n                this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    Sound.prototype.setVolume = function (newVolume, time) {\r\n        if (Engine.audioEngine.canUseWebAudio && this._soundGain) {\r\n            if (time && Engine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\r\n            }\r\n            else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    };\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    Sound.prototype.setPlaybackRate = function (newPlaybackRate) {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            }\r\n            else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    Sound.prototype.getVolume = function () {\r\n        return this._volume;\r\n    };\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n     */\r\n    Sound.prototype.attachToMesh = function (transformNode) {\r\n        var _this = this;\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this.spatialSound) {\r\n            this.spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = function (transformNode) { return _this._onRegisterAfterWorldMatrixUpdate(transformNode); };\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    };\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n     */\r\n    Sound.prototype.detachFromMesh = function () {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    };\r\n    Sound.prototype._onRegisterAfterWorldMatrixUpdate = function (node) {\r\n        if (this._positionInEmitterSpace) {\r\n            node.worldMatrixFromCache.invertToRef(TmpVectors.Matrix[0]);\r\n            this.setPosition(TmpVectors.Matrix[0].getTranslation());\r\n        }\r\n        else {\r\n            if (!node.getBoundingInfo) {\r\n                this.setPosition(node.absolutePosition);\r\n            }\r\n            else {\r\n                var mesh = node;\r\n                var boundingInfo = mesh.getBoundingInfo();\r\n                this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n            }\r\n        }\r\n        if (Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    };\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    Sound.prototype.clone = function () {\r\n        var _this = this;\r\n        if (!this._streaming) {\r\n            var setBufferAndRun = function () {\r\n                if (_this._isReadyToPlay) {\r\n                    clonedSound._audioBuffer = _this.getAudioBuffer();\r\n                    clonedSound._isReadyToPlay = true;\r\n                    if (clonedSound.autoplay) {\r\n                        clonedSound.play(0, _this._offset, _this._length);\r\n                    }\r\n                }\r\n                else {\r\n                    window.setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n            var currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this.spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n            var clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    Sound.prototype.getAudioBuffer = function () {\r\n        return this._audioBuffer;\r\n    };\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    Sound.prototype.getSoundSource = function () {\r\n        return this._soundSource;\r\n    };\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    Sound.prototype.getSoundGain = function () {\r\n        return this._soundGain;\r\n    };\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    Sound.prototype.serialize = function () {\r\n        var serializationObject = {\r\n            name: this.name,\r\n            url: this.name,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this.spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n        if (this.spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Parse a JSON representation of a sound to innstantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a cound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    Sound.Parse = function (parsedSound, scene, rootUrl, sourceSound) {\r\n        var soundName = parsedSound.name;\r\n        var soundUrl;\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        }\r\n        else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n        var options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n        var newSound;\r\n        if (!sourceSound) {\r\n            newSound = new Sound(soundName, soundUrl, scene, function () {\r\n                scene._removePendingData(newSound);\r\n            }, options);\r\n            scene._addPendingData(newSound);\r\n        }\r\n        else {\r\n            var setBufferAndRun = function () {\r\n                if (sourceSound._isReadyToPlay) {\r\n                    newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                    newSound._isReadyToPlay = true;\r\n                    if (newSound.autoplay) {\r\n                        newSound.play(0, newSound._offset, newSound._length);\r\n                    }\r\n                }\r\n                else {\r\n                    window.setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n        if (parsedSound.position) {\r\n            var soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            var connectedMesh = scene.getMeshByID(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n        return newSound;\r\n    };\r\n    /** @hidden */\r\n    Sound._SceneComponentInitialization = function (_) {\r\n        throw _DevTools.WarnImport(\"AudioSceneComponent\");\r\n    };\r\n    return Sound;\r\n}());\r\nexport { Sound };\r\n"]},"metadata":{},"sourceType":"module"}